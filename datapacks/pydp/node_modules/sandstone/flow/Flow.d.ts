import { Execute } from "../commands/implementations/Execute";
import { ConditionClass } from "../variables/index";
import { Score } from "../variables/Score";
import { CombinedConditions } from "./conditions";
import type { BLOCKS, Coordinates, SingleEntityArgument } from "../arguments/index";
import type { LiteralUnion } from "../generalTypes";
import type { CommandsRoot } from "../commands/index";
import type { Datapack } from "../datapack/index";
import type { CommandArgs } from "../datapack/minecraft";
import type { ConditionType } from "./conditions";
declare type FlowStatementConfig = {
    callbackName: string;
    absoluteName?: string;
    forceInlineScore?: Score;
} & ({
    initialCondition: false;
    loopCondition: false;
    condition?: undefined;
} | {
    initialCondition: boolean;
    loopCondition: boolean;
    condition: ConditionType;
});
export declare class Flow {
    private commandsRoot;
    private datapack;
    arguments: CommandArgs;
    executeState: CommandsRoot['executeState'];
    constructor(datapack: Datapack);
    /** CONDITIONS */
    /**
     * Compares the block at a given position to a given block. Suceeds if both are identical.
     *
     * @param pos Position of a target block to test.
     *
     * @param block A block to test against.
     */
    block: (coords: Coordinates, block: LiteralUnion<BLOCKS>) => ConditionClass;
    /**
     * Compares the blocks in two equally sized volumes. Suceeds if both are identical.
     *
     * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
     *
     * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
     *
     * @param destination
     * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
     * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
     *
     * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
     */
    blocks: (start: Coordinates, end: Coordinates, destination: Coordinates, scanMode: 'all' | 'masked') => ConditionClass;
    /**
     * Checks if the given target has any data for a given tag.
     *
     * @example
     * // Check whether the current block has an Inventory
     * _.if(_.data.block(rel(0, 0, 0), 'Inventory'), () => {
     *   say('The current block has data in its Inventory tag.')
     * })
     *
     * // Check whether the player has at least one slot with dirt
     * _.if(_.data.entity(`@r`, 'Inventory[{id: "minecraft:dirt"}]'), () => {
     *   say('The random player has dirt.')
     * })
     *
     * // Check whether there is data in the "Test" tag of the storage
     * _.if(_.data.storage('namespace:mystorage', 'Test'), () => {
     *   say('There is data in the "Test" tag of mystorage.')
     * })
     */
    data: {
        /**
         * Checks whether the targeted block has any data for a given tag.
         * @param pos Position of the block to be tested.
         * @param path Data tag to check for.
         */
        block: (pos: Coordinates, path: string) => ConditionClass;
        /**
         * Checks whether the targeted entity has any data for a given tag
         * @param target One single entity to be tested.
         * @param path Data tag to check for.
         */
        entity: (target: SingleEntityArgument, path: string) => ConditionClass;
        /**
         * Checks whether the targeted storage has any data for a given tag
         * @param source The storage to check in.
         * @param path Data tag to check for.
         */
        storage: (source: string, path: string) => ConditionClass;
    };
    /** Logical operators */
    /**
     * Check if multiple conditions are true at the same time.
     * @param conditions The conditions to check.
     */
    and: (...conditions: (ConditionType)[]) => CombinedConditions;
    /**
     * Check if at least one of the given conditions is true.
     * @param conditions The conditions to check.
     */
    or: (...conditions: (ConditionType)[]) => CombinedConditions;
    /**
     * Check if the given condition is not true.
     * @param condition The condition to check.
     */
    not: (condition: ConditionType) => CombinedConditions;
    /** Flow statements */
    flowStatementAsync: (callback: () => Promise<void>, config: FlowStatementConfig) => Promise<void>;
    flowStatement: (callback: () => void, config: FlowStatementConfig) => void;
    private if_;
    if: <R extends void | Promise<void>>(condition: ConditionType, callback: () => R) => R extends void ? ElifElseFlow<R> : ElifElseFlow<R> & PromiseLike<void>;
    binaryMatch: (score: Score, minimum: number, maximum: number, callback: (num: number) => void) => void;
    private _while;
    while: <R extends void | Promise<void>>(condition: ConditionClass | CombinedConditions, callback: () => R) => R;
    doWhile: <R extends void | Promise<void>>(condition: ConditionClass | CombinedConditions, callback: () => R) => R;
    binaryFor: (from: Score | number, to: Score | number, callback: (amount: number) => void, maximum?: number) => void;
    forRange: <R extends void | Promise<void>>(from: Score | number, to: Score | number, callback: (score: Score) => R) => void | Promise<void>;
    forScore: <R extends void | Promise<void>>(score: Score | number, condition: ConditionType | ((score: Score) => ConditionType), modifier: (score: Score) => void, callback: (score: Score) => R) => R;
    private register;
    get execute(): Omit<Execute<Flow>, 'run' | 'runOne'>;
}
export declare type PublicFlow = Omit<Flow, 'arguments' | 'flowStatement' | 'elseIf' | 'else'>;
declare type ElifElseFlow<R extends void | Promise<void>> = {
    elseIf: (condition: ConditionType, callback: () => R) => (R extends void ? ElifElseFlow<R> : ElifElseFlow<R> & PromiseLike<void>);
    else: (callback: () => R) => void;
};
export {};
