import { CommandsRoot } from "../commands/index";
import { Flow } from "../flow/index";
import { DataInstance, DataPointInstance, TargetlessDataInstance } from "../variables/Data";
import { BasePathClass } from "./BasePath";
import { ResourcesTree } from "./resourcesTree";
import type { JSONTextComponent, OBJECTIVE_CRITERION, TimeArgument } from "../arguments/index";
import type { BASIC_CONFLICT_STRATEGIES, HideFunctionProperties, LiteralUnion } from "../generalTypes";
import type { AdvancementOptions, LootTableOptions, MCFunctionClass, MCFunctionOptions, PredicateOptions, RecipeOptions, TagOptions } from "../resources/index";
import type { ObjectiveInstance, SelectorCreator } from "../variables/index";
import type { DATA_TARGET, DATA_TYPES } from "../variables/Data";
import type { Score } from "../variables/Score";
import type { BasePathInstance, BasePathOptions } from "./BasePath";
import type { CommandArgs } from "./minecraft";
import type { FunctionResource, ResourceConflictStrategy, ResourceOnlyTypeMap, ResourcePath } from "./resourcesTree";
import type { SaveOptions } from "./saveDatapack";
declare type ScriptArguments = {
    /** The name of the data pack. */
    dataPackName: string;
    /** The destination folder of the data pack. `null` if there is only a custom file handler, or nothing at all. */
    destination: string | null;
};
export interface SandstoneConfig {
    /**
     * The default namespace for the data pack.
     * It can be changed for each resources, individually or using Base Paths.
     */
    namespace: string;
    /**
     * The name of the datapack.
     */
    name: string;
    /**
     * The description of the datapack.
     * Can be a single string or a JSON Text Component
     * (like in /tellraw or /title).
     */
    description: JSONTextComponent;
    /**
     * The format version of the data pack.
     * Can change depending on the versions of Minecraft.
     *
     * @see [https://minecraft.gamepedia.com/Data_Pack#pack.mcmeta](https://minecraft.gamepedia.com/Data_Pack#pack.mcmeta)
     */
    formatVersion: number;
    /**
     * A custom path to your .minecraft folder,
     * in case you changed the default and Sandstone fails to find it.
     */
    minecraftPath?: string;
    /**
     * A unique identifier that is used to distinguish your variables from other Sandstone data pack variables.
     *
     * It must be a string of valid scoreboard characters.
     */
    packUid: string;
    /** All the options to save the data pack. */
    saveOptions: {
        /**
         * A custom handler for saving files. If specified, files won't be saved anymore, you will have to handle that yourself.
         */
        customFileHandler?: SaveOptions['customFileHandler'];
        /**
         * The indentation to use for all JSON & MCMeta files. This argument is the same than `JSON.stringify` 3d argument.
         */
        indentation?: string | number;
        /**
         * The world to save the data pack in.
         *
         * Incompatible with `root` and `path`.
         */
        world?: string;
        /**
         * Whether to save the data pack in the `.minecraft/datapacks` folder.
         *
         * Incompatible with `world` and `path`.
         */
        root?: true;
        /**
         * A custom path to save the data pack at.
         *
         * Incompatible with `root` and `world`.
         */
        path?: string;
    };
    /** Some scripts that can run at defined moments. */
    scripts?: {
        /** A script running before Sandstone starts importing source files. */
        beforeAll?: (options: ScriptArguments) => (void | Promise<void>);
        /** A script running before Sandstone starts saving the files. */
        beforeSave?: (options: ScriptArguments) => (void | Promise<void>);
        /** A script running after Sandstone saved all files. */
        afterAll?: (options: ScriptArguments) => (void | Promise<void>);
    };
    /**
     * The strategy to use when 2 resources of the same type (Advancement, MCFunctions...) have the same name.
     */
    onConflict?: {
        /**
         * The default conflict strategy to use for all resources.
         *
         * @default
         * 'warn'
         */
        default?: BASIC_CONFLICT_STRATEGIES;
        /**
         * The conflict strategy to use for Advancements.
         * Will override the defined `default` strategy.
         */
        advancement?: AdvancementOptions['onConflict'];
        /**
         * The conflict strategy to use for Loot Tables.
         * Will override the defined `default` strategy.
         */
        lootTable?: LootTableOptions['onConflict'];
        /**
         * The conflict strategy to use for MCFunctions.
         * Will override the defined `default` strategy.
         */
        mcFunction?: MCFunctionOptions['onConflict'];
        /**
         * The conflict strategy to use for Predicates.
         * Will override the defined `default` strategy.
         */
        predicate?: PredicateOptions['onConflict'];
        /**
         * The conflict strategy to use for RecipeOptions.
         * Will override the defined `default` strategy.
         */
        recipe?: RecipeOptions['onConflict'];
        /**
         * The conflict strategy to use for Tags.
         * Will override the defined `default` strategy.
         */
        tag?: TagOptions['onConflict'];
    };
}
export declare type MCFunctionInstance<RETURN extends (void | Promise<void>) = (void | Promise<void>)> = HideFunctionProperties<{
    (): RETURN;
} & Pick<MCFunctionClass, 'schedule' | 'generate' | 'toString' | 'toJSON'>>;
export default class Datapack {
    basePath: BasePathClass<undefined, undefined>;
    defaultNamespace: string;
    currentFunction: FunctionResource | null;
    resources: ResourcesTree;
    objectives: Map<string, ObjectiveInstance<string>>;
    commandsRoot: CommandsRoot;
    constants: Set<number>;
    rootFunctions: Set<MCFunctionClass>;
    static anonymousScoreId: number;
    flow: Flow;
    initCommands: CommandArgs[];
    packUid: string;
    constructor(packUid: string, namespace: string);
    reset: () => void;
    /** Get information like the path, namespace etc... from a resource name */
    getResourcePath(resourceName: string): {
        /** The namespace of the resource */
        namespace: string;
        /**
         * The path of the resource, EXCLUDING the resource name and the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').path === ['test']
         */
        path: string[];
        /**
         * The path of the resource, EXCLUDING the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').fullPath === ['test', 'myfunction']
         */
        fullPath: string[];
        /**
         * The path of the resource, INCLUDING the resource name and the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').fullPathWithNamespace === ['minecraft', 'test', 'myfunction']
         */
        fullPathWithNamespace: ResourcePath;
        /**
         * The name of the resource itself. Does not include the path nor the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').name === 'myfunction'
         */
        name: string;
        /**
         * The full name of the resource itself, as it should be refered in the datapack.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').name === 'minecraft:test/myfunction'
         */
        fullName: string;
    };
    /**
     * Creates and enters a new root Minecraft function.
     *
     * @param functionName The name of the function to create
     */
    createEnterRootFunction(functionName: string, conflictStrategy: ResourceConflictStrategy<'functions'>): string;
    /**
     * Returns a unique name for a function, from an original name, by checking if it already exists in the given folder.
     * @param functionName the original name for the function.
     * @param folder the folder to check into.
     */
    private getUniqueNameFromFolder;
    /**
     * Get a unique name for a child function of a parent function, from an original name.
     * @param childName The original name for the child function.
     * @param parentFunction The parent function to find a child's name for. Defaults to current function.
     */
    getUniqueChildName(childName: string, parentFunction?: FunctionResource | null): {
        /** The namespace of the resource */
        namespace: string;
        /**
         * The path of the resource, EXCLUDING the resource name and the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').path === ['test']
         */
        path: string[];
        /**
         * The path of the resource, EXCLUDING the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').fullPath === ['test', 'myfunction']
         */
        fullPath: string[];
        /**
         * The path of the resource, INCLUDING the resource name and the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').fullPathWithNamespace === ['minecraft', 'test', 'myfunction']
         */
        fullPathWithNamespace: ResourcePath;
        /**
         * The name of the resource itself. Does not include the path nor the namespace.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').name === 'myfunction'
         */
        name: string;
        /**
         * The full name of the resource itself, as it should be refered in the datapack.
         *
         * @example
         * getResourcePath('minecraft:test/myfunction').name === 'minecraft:test/myfunction'
         */
        fullName: string;
    };
    /**
     * Creates a new child function of the current function.
     * @param functionName The name of the child function.
     * @param parentFunction The function for which a child must be created. Defaults to the current function.
     */
    createChildFunction(functionName: string, parentFunction?: FunctionResource | null): {
        childFunction: FunctionResource;
        functionName: string;
    };
    /**
     * Creates and enters a new child function of the current function.
     * @param functionName The name of the child function.
     */
    createEnterChildFunction(functionName: string): string;
    createCallbackMCFunction(name: string, callback: () => (void | Promise<void>), asChild: boolean): MCFunctionInstance;
    /**
     * Recursively exit the current function of the datapack.
     *
     * If we're in a child function of a root function (or a n-th child), it will exit them too.
     */
    private exitRootFunction;
    /**
     * Get the parent function of the current function.
     */
    getParentFunction(): {
        path: ResourcePath;
        children: Map<string, import("./resourcesTree").FolderOrFile<{
            commands: CommandArgs[];
        }, ResourcePath>>;
    } & {
        isResource: true;
    } & {
        commands: CommandArgs[];
    };
    /**
     * Exit the current child function, and enter the parent function.
     */
    exitChildFunction(): void;
    registerNewObjective: (objective: ObjectiveInstance<string>) => void;
    /**
     * Register a new command in the current function.
     * @param commandArgs The arguments of the command to add.
     */
    registerNewCommand: (commandArgs: CommandArgs) => void;
    /**
     * Register a new numeric constant.
     */
    registerNewConstant(amount: number): void;
    /**
     * Add a function to a given function tag
     */
    addFunctionToTag(mcfunction: string, tag: string, index?: number | undefined): void;
    /** UTILS */
    Objective: {
        /**
         * Create a new objective. Defaults to `dummy` if unspecified.
         * @param name The name of the objective
         */
        create: (name: string, criteria?: LiteralUnion<OBJECTIVE_CRITERION>, display?: JSONTextComponent | undefined) => ObjectiveInstance;
        /** Get an existing objective. */
        get: (name: string) => ObjectiveInstance;
    };
    /** Get an objective, and create it if it does not exists. */
    getCreateObjective(name: string, criteria: string, display?: JSONTextComponent): ObjectiveInstance<string | undefined>;
    get rootObjective(): ObjectiveInstance<string | undefined>;
    Variable: ((
    /**
     * Creates a dynamic numeric variable, represented by an anonymous & unique score.
     *
     * @param initialValue The initial value of the variable. If left unspecified,
     * or if `undefined`, then the score will not be initialized.
     *
     * @param name A name that can be useful for debugging.
     */
    (initialValue?: number | Score | undefined, name?: string) => Score) & (
    /**
     * Creates a dynamic numeric variable, represented by an anonymous & unique score.
     *
     * @param nbt The NBT value to set the Variable to.
     *
     * @param scale The scale to multiply the value by. Defaults to 1.
     *
     * @param name A name that can be useful for debugging.
     */
    (nbt: DataPointInstance, scale?: number, name?: string) => Score));
    Selector: SelectorCreator;
    Data: <TYPE extends DATA_TYPES, TARGET extends DATA_TARGET[TYPE] | undefined = undefined>(type: TYPE, target?: TARGET | undefined) => TARGET extends undefined ? TargetlessDataInstance<DATA_TYPES> : DataInstance<DATA_TYPES>;
    /** A BasePath changes the base namespace & directory of nested resources. */
    BasePath: <N extends string | undefined, D extends string | undefined>(basePath: BasePathOptions<N, D>) => BasePathInstance<N, D>;
    addResource: <T extends keyof import("./resourcesTree").ResourceTypeMap, U extends ResourceOnlyTypeMap[T] = ResourceOnlyTypeMap[T]>(name: string, type: T, resource: Omit<U, "children" | "isResource" | "path">, conflictStrategy: ResourceConflictStrategy<T, ResourceOnlyTypeMap[T]>) => void;
    sleep: (delay: TimeArgument) => PromiseLike<void>;
    /**
     * Saves the datapack to the file system.
     *
     * @param name The name of the Datapack
     * @param options The save options
     */
    save: (name: string, options: SaveOptions) => Promise<{
        destination: string | null;
    }>;
}
export {};
