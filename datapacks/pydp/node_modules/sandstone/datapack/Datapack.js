"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const _commands_1 = require("../commands/index");
const _flow_1 = require("../flow/index");
const conditions_1 = require("../flow/conditions");
const _variables_1 = require("../variables/index");
const Data_1 = require("../variables/Data");
const BasePath_1 = require("./BasePath");
const minecraft_1 = require("./minecraft");
const resourcesTree_1 = require("./resourcesTree");
const saveDatapack_1 = require("./saveDatapack");
class Datapack {
    constructor(packUid, namespace) {
        this.reset = () => {
            this.basePath = new BasePath_1.BasePathClass(this, {});
            this.currentFunction = null;
            this.resources = new resourcesTree_1.ResourcesTree();
            this.objectives = new Map();
            this.constants = new Set();
            this.rootFunctions = new Set();
            this.commandsRoot.reset();
            this.flow = new _flow_1.Flow(this);
            this.initCommands = [];
            Datapack.anonymousScoreId = 0;
            conditions_1.resetConditionScore(this);
        };
        this.registerNewObjective = (objective) => {
            if (this.objectives.has(objective.name)) {
                throw new Error(`An objective named "${objective.name}" already exists.`);
            }
            this.objectives.set(objective.name, objective);
        };
        /**
         * Register a new command in the current function.
         * @param commandArgs The arguments of the command to add.
         */
        this.registerNewCommand = (commandArgs) => {
            if (!this.currentFunction || !this.currentFunction.isResource) {
                throw Error(`Adding a command outside of a registered function: /${commandArgs.join(' ')}`);
            }
            this.currentFunction.commands.push(commandArgs);
        };
        /** UTILS */
        this.Objective = {
            /**
             * Create a new objective. Defaults to `dummy` if unspecified.
             * @param name The name of the objective
             */
            create: (name, criteria = 'dummy', display) => {
                if (name.length > 16) {
                    throw new Error(`Objectives cannot have names with more than 16 characters. Got ${name.length} with objective "${name}".`);
                }
                const objective = new _variables_1.ObjectiveClass(this.commandsRoot, name, criteria, display);
                const value = objective.ScoreHolder;
                const { name: _, ...objectiveExceptName } = objective;
                const objectiveInstance = Object.assign(objective.ScoreHolder, objectiveExceptName);
                const descriptor = Object.getOwnPropertyDescriptor(value, 'name');
                descriptor.value = objective.name;
                Object.defineProperty(value, 'name', descriptor);
                this.registerNewObjective(objectiveInstance);
                return objectiveInstance;
            },
            /** Get an existing objective. */
            get: (name) => {
                if (name.length > 16) {
                    throw new Error(`Objectives cannot have names with more than 16 characters. Got ${name.length} with objective "${name}".`);
                }
                const objective = new _variables_1.ObjectiveClass(this.commandsRoot, name);
                const value = objective.ScoreHolder;
                const { name: _, ...objectiveExceptName } = objective;
                const objectiveInstance = Object.assign(objective.ScoreHolder, objectiveExceptName);
                const descriptor = Object.getOwnPropertyDescriptor(value, 'name');
                descriptor.value = objective.name;
                Object.defineProperty(value, 'name', descriptor);
                return objectiveInstance;
            },
        };
        this.Variable = (initialValue, nameOrScale, maybeName) => {
            // Get the objective
            const datapack = this.commandsRoot.Datapack;
            const score = datapack.rootObjective;
            if (initialValue instanceof Data_1.DataPointInstance) {
                // If the value is a data point, leverage the .set method
                return this.Variable(undefined, maybeName).set(initialValue, nameOrScale);
            }
            const name = nameOrScale;
            // Get the specific anonymous score
            const id = Datapack.anonymousScoreId;
            Datapack.anonymousScoreId += 1;
            const anonymousScore = score(`${name !== null && name !== void 0 ? name : 'anon'}_${datapack.packUid}_${id}`);
            if (initialValue !== undefined) {
                if (this.currentFunction !== null) {
                    anonymousScore.set(initialValue);
                }
                else {
                    this.initCommands.push(['scoreboard', 'players', 'set', anonymousScore.target, anonymousScore.objective, initialValue]);
                }
            }
            return anonymousScore;
        };
        this.Selector = ((target, properties) => new _variables_1.SelectorClass(this.commandsRoot, target, properties));
        this.Data = (type, target) => {
            if (target) {
                return new Data_1.DataInstance(this, type, target);
            }
            return new Data_1.TargetlessDataInstance(this, type);
        };
        /** A BasePath changes the base namespace & directory of nested resources. */
        this.BasePath = (basePath) => {
            const basePathInstance = new BasePath_1.BasePathClass(this, basePath);
            const returnFunction = basePathInstance.getResourceName;
            Object.assign(returnFunction, basePathInstance);
            return returnFunction;
        };
        this.addResource = (name, type, resource, conflictStrategy) => {
            this.resources.addResource(type, {
                ...resource,
                children: new Map(),
                isResource: true,
                path: this.getResourcePath(name).fullPathWithNamespace,
            }, conflictStrategy);
        };
        this.sleep = (delay) => {
            const SLEEP_CHILD_NAME = '__sleep';
            if (!this.currentFunction) {
                throw new Error('Cannot call `sleep` outside of a MCFunction.');
            }
            // If we're already in a "sleep" child, go to the parent function. It avoids childs' names becoming namespace:function/__sleep/__sleep/__sleep etc...
            const { fullPath } = this.getResourcePath(minecraft_1.toMCFunctionName(this.currentFunction.path));
            const inSleepFunction = fullPath[fullPath.length - 1].startsWith(SLEEP_CHILD_NAME);
            let parentFunction;
            // If we're in a sleep function, the parent function of the new child is the current function's parent. Else, the parent is the current function.
            if (inSleepFunction) {
                parentFunction = this.getParentFunction();
            }
            else {
                parentFunction = this.currentFunction;
            }
            const newFunction = this.createChildFunction(SLEEP_CHILD_NAME, parentFunction);
            this.commandsRoot.schedule.function(newFunction.functionName, delay, 'append');
            return ({
                then: (async (onfullfilled) => {
                    // Enter child "sleep"
                    this.currentFunction = newFunction.childFunction;
                    const result = await (onfullfilled === null || onfullfilled === void 0 ? void 0 : onfullfilled());
                    return result;
                }),
            });
        };
        /**
         * Saves the datapack to the file system.
         *
         * @param name The name of the Datapack
         * @param options The save options
         */
        this.save = async (name, options) => {
            var _a;
            console.log(chalk_1.default `âŒ› {gray Starting compilation...}`);
            // First, generate all functions
            for (const mcfunction of this.rootFunctions) {
                // eslint-disable-next-line no-await-in-loop
                await mcfunction.generate();
            }
            // Then, generate the init function.
            this.createEnterRootFunction('__init__', 'ignore');
            // Start by generating constants
            if (this.constants.size > 0) {
                this.commandsRoot.scoreboard.objectives.add('sandstone_const', 'dummy', [{ text: 'Sandstone Constants' }]);
                this.constants.forEach((constant) => {
                    this.commandsRoot.scoreboard.players.set(constant, 'sandstone_const', constant);
                });
            }
            // Then, generate objectives
            if (this.objectives.size > 0) {
                this.objectives.forEach((objective) => {
                    this.commandsRoot.scoreboard.objectives.add(objective.name, objective.criterion, objective._displayRaw);
                });
            }
            // Then, add init commands
            for (const commandArgs of this.initCommands) {
                this.registerNewCommand(commandArgs);
            }
            // Delete __init__ function if it's empty
            if (((_a = this.currentFunction) === null || _a === void 0 ? void 0 : _a.isResource) && this.currentFunction.commands.length === 0) {
                this.resources.deleteResource(this.currentFunction.path, 'functions');
            }
            else {
                // Else, put the __init__ function in the minecraft:load tag
                this.addFunctionToTag(minecraft_1.toMCFunctionName(this.currentFunction.path), 'minecraft:load', 0);
            }
            this.exitRootFunction();
            return saveDatapack_1.saveDatapack(this.resources, name, options);
        };
        this.packUid = packUid;
        this.basePath = new BasePath_1.BasePathClass(this, {});
        this.defaultNamespace = namespace;
        this.currentFunction = null;
        this.resources = new resourcesTree_1.ResourcesTree();
        this.objectives = new Map();
        this.constants = new Set();
        this.rootFunctions = new Set();
        this.commandsRoot = new _commands_1.CommandsRoot(this);
        this.flow = new _flow_1.Flow(this);
        this.initCommands = [];
    }
    /** Get information like the path, namespace etc... from a resource name */
    getResourcePath(resourceName) {
        let namespace = this.defaultNamespace;
        let fullName = resourceName;
        if (resourceName.includes(':')) {
            ([namespace, fullName] = resourceName.split(':'));
        }
        const fullPath = fullName.split('/');
        const name = fullPath[fullPath.length - 1];
        const path = fullPath.slice(0, -1);
        return {
            namespace, path, fullPath, name, fullPathWithNamespace: [namespace, ...fullPath], fullName: `${namespace}:${fullName}`,
        };
    }
    /**
     * Creates and enters a new root Minecraft function.
     *
     * @param functionName The name of the function to create
     */
    createEnterRootFunction(functionName, conflictStrategy) {
        const functionPath = this.getResourcePath(functionName).fullPathWithNamespace;
        this.currentFunction = this.resources.addResource('functions', {
            children: new Map(), commands: [], isResource: true, path: functionPath,
        }, conflictStrategy);
        return minecraft_1.toMCFunctionName(functionPath);
    }
    /**
     * Returns a unique name for a function, from an original name, by checking if it already exists in the given folder.
     * @param functionName the original name for the function.
     * @param folder the folder to check into.
     */
    getUniqueNameFromFolder(functionName, folder) {
        let newName = functionName;
        const newNameTemplate = `${newName}_{}`;
        let i = 2;
        // If the current "new name" already exists in the Datapack, increment `i` and apply the template
        while (folder.children.has(newName)) {
            newName = newNameTemplate.replace('{}', i.toString());
            i += 1;
        }
        return newName;
    }
    /**
     * Get a unique name for a child function of a parent function, from an original name.
     * @param childName The original name for the child function.
     * @param parentFunction The parent function to find a child's name for. Defaults to current function.
     */
    getUniqueChildName(childName, parentFunction = this.currentFunction) {
        if (!parentFunction) {
            throw new Error('Trying to get a unique child name outside a root function.');
        }
        const newName = this.getUniqueNameFromFolder(childName, parentFunction);
        const fullName = minecraft_1.toMCFunctionName([...parentFunction.path, newName]);
        return this.getResourcePath(fullName);
    }
    /**
     * Creates a new child function of the current function.
     * @param functionName The name of the child function.
     * @param parentFunction The function for which a child must be created. Defaults to the current function.
     */
    createChildFunction(functionName, parentFunction = this.currentFunction) {
        if (!parentFunction) {
            throw Error('Entering child function without registering a root function');
        }
        const { name: childName, fullName, fullPathWithNamespace } = this.getUniqueChildName(functionName, parentFunction);
        // Update the current function - it now is the child function.
        const emptyFunction = {
            children: new Map(),
            isResource: true,
            commands: [], path: fullPathWithNamespace,
        };
        parentFunction.children.set(childName, emptyFunction);
        // Return its full minecraft name
        return {
            functionName: fullName,
            childFunction: emptyFunction,
        };
    }
    /**
     * Creates and enters a new child function of the current function.
     * @param functionName The name of the child function.
     */
    createEnterChildFunction(functionName) {
        const { childFunction, functionName: realFunctionName } = this.createChildFunction(functionName);
        this.currentFunction = childFunction;
        // Return its full minecraft name
        return realFunctionName;
    }
    createCallbackMCFunction(name, callback, asChild) {
        let fullName;
        if (asChild) {
            fullName = minecraft_1.toMCFunctionName(this.getUniqueChildName(name).fullPathWithNamespace);
        }
        else {
            fullName = name;
        }
        return this.basePath.MCFunction(fullName, callback);
    }
    /**
     * Recursively exit the current function of the datapack.
     *
     * If we're in a child function of a root function (or a n-th child), it will exit them too.
     */
    exitRootFunction() {
        if (!this.currentFunction) {
            throw Error('Exiting a not-existing function');
        }
        this.currentFunction = null;
    }
    /**
     * Get the parent function of the current function.
     */
    getParentFunction() {
        if (!this.currentFunction) {
            throw Error('Exiting a not-existing function');
        }
        const parentPath = this.currentFunction.path.slice(0, -1);
        return this.resources.getResource(parentPath, 'functions');
    }
    /**
     * Exit the current child function, and enter the parent function.
     */
    exitChildFunction() {
        this.currentFunction = this.getParentFunction();
    }
    /**
     * Register a new numeric constant.
     */
    registerNewConstant(amount) {
        this.constants.add(amount);
    }
    /**
     * Add a function to a given function tag
     */
    addFunctionToTag(mcfunction, tag, index) {
        const { namespace, fullPath, name } = this.getResourcePath(tag);
        const tickResource = this.resources.getOrAddResource('tags', {
            children: new Map(),
            isResource: true,
            path: [namespace, 'functions', ...fullPath],
            values: [],
            replace: false,
        });
        const { fullName } = this.getResourcePath(mcfunction);
        if (index === undefined) {
            tickResource.values.push(fullName);
        }
        else {
            // Insert at given index
            tickResource.values.splice(index, 0, fullName);
        }
    }
    /** Get an objective, and create it if it does not exists. */
    getCreateObjective(name, criteria, display) {
        try {
            return this.Objective.create(name, criteria, display);
        }
        catch (e) {
            return this.objectives.get(name);
        }
    }
    get rootObjective() {
        return this.getCreateObjective('sandstone', 'dummy', [{ text: 'Sandstone', color: 'gold' }, ' internals']);
    }
}
exports.default = Datapack;
Datapack.anonymousScoreId = 0;
