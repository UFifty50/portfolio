"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveDatapack = exports.getDestinationPath = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const filesystem_1 = require("./filesystem");
const packMcMeta_json_1 = __importDefault(require("./packMcMeta.json"));
const writeFileAsync = async (path_, content) => {
    const fs = await Promise.resolve().then(() => __importStar(require('graceful-fs')));
    const { promisify } = await Promise.resolve().then(() => __importStar(require('util')));
    const writeFile = promisify(fs.writeFile);
    return writeFile(path_, content);
};
const writeFile = (saveObject) => writeFileAsync(path_1.default.join(saveObject.rootPath, saveObject.relativePath), saveObject.content);
function hasWorld(arg) {
    return Object.prototype.hasOwnProperty.call(arg, 'world');
}
function hasRoot(arg) {
    return Object.prototype.hasOwnProperty.call(arg, 'asRootDatapack');
}
function hasCustomPath(arg) {
    return Object.prototype.hasOwnProperty.call(arg, 'customPath');
}
function saveResource(rootPath, type, resource, options, getRepresentation, getDisplayTitle) {
    // This ensure the function is async, and can be await
    const writeFileToDisk = async (info) => {
        const customFileHandler = options === null || options === void 0 ? void 0 : options.customFileHandler;
        if (!customFileHandler && info.rootPath) {
            // If we don't have a custom file handler, info.rootPath is necessarily not null
            return writeFile(info);
        }
        if (customFileHandler) {
            return customFileHandler(info);
        }
        return undefined;
    };
    const promises = [];
    if (resource.isResource) {
        const [namespace, ...folders] = resource.path;
        const basePath = path_1.default.join('data', namespace, type);
        const fileName = folders.pop();
        const resourceFolder = path_1.default.join(basePath, ...folders);
        if (!options.dryRun) {
            if (!options.customFileHandler && rootPath) {
                filesystem_1.createDirectory(path_1.default.join(rootPath, resourceFolder));
            }
            // Write the commands to the file system
            const resourcePath = path_1.default.join(resourceFolder, `${fileName}.${type === 'functions' ? 'mcfunction' : 'json'}`);
            promises.push(writeFileToDisk({
                packType: 'datapack',
                type,
                content: getRepresentation(resource, false),
                rootPath,
                relativePath: resourcePath,
                resource,
                saveOptions: options,
            }));
        }
        if (options.verbose) {
            console.log(chalk_1.default `{cyan ## ${getDisplayTitle(namespace, folders, fileName)}}`);
            console.log(getRepresentation(resource, true));
            console.log();
        }
    }
    for (const r of resource.children.values()) {
        promises.push(...saveResource(rootPath, type, r, options, getRepresentation, getDisplayTitle));
    }
    return promises;
}
function getDestinationPath(name, options) {
    if (hasWorld(options) && options.world !== undefined) {
        return path_1.default.join(filesystem_1.getWorldPath(options === null || options === void 0 ? void 0 : options.world, options === null || options === void 0 ? void 0 : options.minecraftPath), 'datapacks', name);
    }
    if (hasRoot(options) && options.asRootDatapack !== undefined) {
        return path_1.default.join(filesystem_1.getMinecraftPath(), 'datapacks', name);
    }
    if (hasCustomPath(options) && options.customPath !== undefined) {
        return path_1.default.join(options.customPath, name);
    }
    return null;
}
exports.getDestinationPath = getDestinationPath;
/**
 * Saves the datapack to the file system.
 *
 * @param functions A mapping between function full names and their commands.
 * @param name The name of the Datapack
 * @param options The save options.
 */
async function saveDatapack(resources, name, options) {
    var _a;
    // This ensure the function is async, and can be await
    const writeFileToDisk = async (info) => {
        var _a;
        const func = (_a = options === null || options === void 0 ? void 0 : options.customFileHandler) !== null && _a !== void 0 ? _a : writeFile;
        return func(info);
    };
    const indentation = (_a = options.indentation) !== null && _a !== void 0 ? _a : 2;
    try {
        const start = Date.now();
        // Files saving promises
        const promises = [];
        // Find the save path
        const rootPath = getDestinationPath(name, options);
        if (options.description !== undefined) {
            packMcMeta_json_1.default.pack.description = options.description;
        }
        if (options.formatVersion !== undefined) {
            packMcMeta_json_1.default.pack.pack_format = options.formatVersion;
        }
        if (!options.dryRun) {
            // Clean the old working directory
            if (rootPath !== null) {
                filesystem_1.deleteDirectory(rootPath);
                filesystem_1.createDirectory(rootPath);
                // Overwrite it
                promises.push(writeFileToDisk({
                    packType: 'datapack',
                    type: 'raw',
                    resource: packMcMeta_json_1.default,
                    content: JSON.stringify(packMcMeta_json_1.default, null, indentation),
                    rootPath,
                    relativePath: 'pack.mcmeta',
                    saveOptions: options,
                }));
            }
        }
        for (const n of resources.namespaces.values()) {
            // Save functions
            for (const f of n.functions.values()) {
                promises.push(...saveResource(rootPath, 'functions', f, options, 
                // To display a function, we join their arguments. If we're in a console display, we put comments in gray.
                (func, consoleDisplay) => {
                    const repr = [...func.commands].map((command) => command.join(' ')).join('\n');
                    if (consoleDisplay) {
                        return repr.replace(/^#(.+)/gm, chalk_1.default.gray('#$1'));
                    }
                    return repr;
                }, (namespace, folders, fileName) => `Function ${namespace}:${[...folders, fileName].join('/')}`));
            }
            // Save tags
            for (const t of n.tags.values()) {
                promises.push(...saveResource(rootPath, 'tags', t, options, (r) => { var _a; return JSON.stringify({ replace: (_a = r.replace) !== null && _a !== void 0 ? _a : false, values: r.values }, null, indentation); }, (namespace, folders, fileName) => `Tag[${folders[0]}] ${namespace}:${[...folders.slice(1), fileName].join('/')}`));
            }
            // Save advancements
            for (const a of n.advancements.values()) {
                promises.push(...saveResource(rootPath, 'advancements', a, options, (r) => JSON.stringify(r.advancement, null, indentation), (namespace, folders, fileName) => `Avancement ${namespace}:${[...folders, fileName].join('/')}`));
            }
            // Save predicates
            for (const p of n.predicates.values()) {
                promises.push(...saveResource(rootPath, 'predicates', p, options, (r) => JSON.stringify(r.predicate, null, indentation), (namespace, folders, fileName) => `Predicate ${namespace}:${[...folders, fileName].join('/')}`));
            }
            // Save loot tables
            for (const l of n.loot_tables.values()) {
                promises.push(...saveResource(rootPath, 'loot_tables', l, options, (r) => JSON.stringify(r.lootTable, null, indentation), (namespace, folders, fileName) => `Loot table ${namespace}:${[...folders, fileName].join('/')}`));
            }
            // Save recipe
            for (const r of n.recipes.values()) {
                promises.push(...saveResource(rootPath, 'recipes', r, options, (resource) => JSON.stringify(resource.recipe, null, indentation), (namespace, folders, fileName) => `Recipe ${namespace}:${[...folders, fileName].join('/')}`));
            }
        }
        // Wait until all files are written
        await Promise.all(promises);
        if (!options.dryRun && rootPath !== null) {
            console.log(chalk_1.default `{greenBright ✓ Successfully wrote data pack to "${rootPath}".} {gray (${promises.length.toLocaleString()} files - ${(Date.now() - start).toLocaleString()}ms)}`);
        }
        else {
            console.log(chalk_1.default `{greenBright ✓ Successfully compiled data pack.} {gray (${(Date.now() - start).toLocaleString()}ms)}`);
        }
        return {
            destination: rootPath,
        };
    }
    catch (e) {
        console.error(e);
        console.log(chalk_1.default `{redBright ✗ Failed to write datapack. See above for additional information.}`);
        throw e;
    }
}
exports.saveDatapack = saveDatapack;
