import { AdvancementInstance, LootTableInstance, PredicateInstance, RecipeInstance, TagInstance } from "../resources/index";
import type { AdvancementJSON, HintedTagStringType, LootTableJSON, PredicateJSON, RecipeJSON, TAG_TYPES, TagSingleValue } from "../arguments/index";
import type { HideFunctionProperties } from "../generalTypes";
import type { Datapack } from "./index";
import type { AdvancementOptions, LootTableOptions, MCFunctionOptions, PredicateOptions, RecipeOptions, TagOptions } from "../resources/index";
import type { SandstoneConfig } from "../index";
import type { MCFunctionInstance } from "./Datapack";
export declare type BasePathOptions<N extends (undefined | string), D extends (undefined | string)> = {
    /** The namespace all nested resources will be located in. */
    namespace?: N;
    /** The directory all nested resources will be located in. */
    directory?: D;
    /** The default conflict strategies for all nested resources. */
    onConflict?: SandstoneConfig['onConflict'];
};
export declare type BasePathInstance<N extends (undefined | string) = (undefined | string), D extends (undefined | string) = (undefined | string)> = (HideFunctionProperties<BasePathClass<N, D>['getResourceName'] & BasePathClass<N, D>>);
/** Changes the base namespace & directory of nested resources. */
export declare class BasePathClass<N extends (undefined | string) = (undefined | string), D extends (undefined | string) = (undefined | string)> {
    protected datapack: Datapack;
    namespace: N;
    directory: D;
    onConflict: {
        default?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
        advancement?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
        lootTable?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
        mcFunction?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | "append" | "prepend" | undefined;
        predicate?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
        recipe?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
        tag?: import("../generalTypes").BASIC_CONFLICT_STRATEGIES | undefined;
    } | undefined;
    constructor(datapack: Datapack, basePath: BasePathOptions<N, D>);
    /** Validates & crafts the name of a resource. */
    protected getName(name: string): string;
    /**
     * Get a child path of the current base path.
     *
     * The namespace cannot be provided in a child path.
     */
    child: <DIR extends string | undefined>(childPath: Omit<BasePathOptions<undefined, DIR>, "namespace">) => BasePathInstance<N, string>;
    /**
     * Get the name of a resource under this base path. Can also be used with template strings.
     * @param name The basic name of the resource.
     * @returns The name of the resource under this base path.
     *
     * @example
     * >>> const basePath = BasePath({ directory: 'sub/folder', namespace: 'mynamespace' })
     * >>> basePath.getResourceName('my_resource')
     * "mynamespace:sub/folder/my_resource"
     */
    getResourceName: (name: string | TemplateStringsArray) => string;
    /**
     * Create an advancement.
     *
     * @param advancement The actual advancement. You must provide at least a `criteria` for it to be valid.
     *
     * @example
     *
     * Advancement('bred_two_cows', {
     *   criteria: {
     *     'bred_cows': {
     *       trigger: 'minecraft:bred_animals',
     *       conditions: {
     *         child: { type: 'minecraft:cow' }
     *       }
     *     }
     *   }
     * })
     */
    Advancement: <T extends string>(name: string, advancement: AdvancementJSON<T>, options?: AdvancementOptions | undefined) => AdvancementInstance<T>;
    /**
     * Create a loot table.
     *
     * @param lootTable The actual loot table. Each pool must provide a number of `rolls` and a list of `entries` to be valid.
     * Each entry must at least provide its `type` and the type-dependant required properties.
     *
     * @example
     *
     * LootTable('give_diamond', {
     *   pools: [{
     *     rolls: 1,
     *     entries: [{
     *       type: 'item',
     *       name: 'minecraft:diamond',
     *     }],
     *   }],
     * })
     */
    LootTable: (name: string, lootTable: LootTableJSON, options?: LootTableOptions | undefined) => LootTableInstance;
    /**
     * Creates a Minecraft Function.
     *
     * @param name The name of the function.
     * @param callback A callback containing the commands you want in the Minecraft Function.
     */
    MCFunction: <RETURN extends void | Promise<void>>(name: string, callback: () => RETURN, options?: MCFunctionOptions | undefined) => MCFunctionInstance<RETURN>;
    /**
     * Create a predicate.
     *
     * @param predicate The actual predicate. You must provide at least a `condition` for it to be valid.
     *
     * @example
     *
     * Predicate('is_raining', {
     *   condition: 'minecraft:weather_check',
     *   raining: true,
     * })
     */
    Predicate: (name: string, predicate: PredicateJSON, options?: PredicateOptions | undefined) => PredicateInstance;
    /** Create a recipe. */
    Recipe: <P1 extends string, P2 extends string, P3 extends string>(name: string, recipe: RecipeJSON<P1, P2, P3>, options?: RecipeOptions | undefined) => RecipeInstance<P1, P2, P3>;
    /** Create a tag. */
    Tag: <T extends TAG_TYPES>(type: T, name: string, values?: TagSingleValue<HintedTagStringType<T>>[], replace?: boolean | undefined, options?: TagOptions | undefined) => TagInstance<T>;
}
