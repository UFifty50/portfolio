"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePathClass = void 0;
const _resources_1 = require("../resources/index");
/** Remove forward & trailing slashes */
function trimSlashes(str) {
    var _a;
    return (_a = str.replace(/^\/+/, '')) === null || _a === void 0 ? void 0 : _a.replace(/\/+$/, '');
}
/** Tranforms a path to an array of folders. */
function pathToArray(path) {
    return (path !== null && path !== void 0 ? path : '').split('/');
}
/** Changes the base namespace & directory of nested resources. */
class BasePathClass {
    constructor(datapack, basePath) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Get a child path of the current base path.
         *
         * The namespace cannot be provided in a child path.
         */
        this.child = (childPath) => {
            const newDirectory = pathToArray(typeof childPath.directory === 'string' ? trimSlashes(childPath.directory) : undefined);
            const oldDirectory = pathToArray(this.directory);
            return this.datapack.BasePath({
                namespace: this.namespace,
                directory: [...oldDirectory, ...newDirectory].join('/'),
                onConflict: this.onConflict,
            });
        };
        /**
         * Get the name of a resource under this base path. Can also be used with template strings.
         * @param name The basic name of the resource.
         * @returns The name of the resource under this base path.
         *
         * @example
         * >>> const basePath = BasePath({ directory: 'sub/folder', namespace: 'mynamespace' })
         * >>> basePath.getResourceName('my_resource')
         * "mynamespace:sub/folder/my_resource"
         */
        this.getResourceName = (name) => this.getName(typeof name === 'string' ? name : name.join());
        /**
         * Create an advancement.
         *
         * @param advancement The actual advancement. You must provide at least a `criteria` for it to be valid.
         *
         * @example
         *
         * Advancement('bred_two_cows', {
         *   criteria: {
         *     'bred_cows': {
         *       trigger: 'minecraft:bred_animals',
         *       conditions: {
         *         child: { type: 'minecraft:cow' }
         *       }
         *     }
         *   }
         * })
         */
        this.Advancement = (name, advancement, options) => {
            var _a;
            return (new _resources_1.AdvancementInstance(this.datapack, this.getName(name), advancement, { onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.advancement, ...options }));
        };
        /**
         * Create a loot table.
         *
         * @param lootTable The actual loot table. Each pool must provide a number of `rolls` and a list of `entries` to be valid.
         * Each entry must at least provide its `type` and the type-dependant required properties.
         *
         * @example
         *
         * LootTable('give_diamond', {
         *   pools: [{
         *     rolls: 1,
         *     entries: [{
         *       type: 'item',
         *       name: 'minecraft:diamond',
         *     }],
         *   }],
         * })
         */
        this.LootTable = (name, lootTable, options) => {
            var _a;
            return (new _resources_1.LootTableInstance(this.datapack, this.getName(name), lootTable, { onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.lootTable, ...options }));
        };
        /**
         * Creates a Minecraft Function.
         *
         * @param name The name of the function.
         * @param callback A callback containing the commands you want in the Minecraft Function.
         */
        this.MCFunction = (name, callback, options) => {
            var _a;
            const mcfunction = new _resources_1.MCFunctionClass(this.datapack, this.getName(name), callback, {
                onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.mcFunction,
                ...options,
            });
            this.datapack.rootFunctions.add(mcfunction);
            const returnFunction = mcfunction.call;
            // Set the function's name
            const descriptor = Object.getOwnPropertyDescriptor(returnFunction, 'name');
            descriptor.value = mcfunction.name;
            Object.defineProperty(returnFunction, 'name', descriptor);
            // Set all properties, except for "name"
            const { name: _, ...mcfunctionClone } = mcfunction;
            Object.assign(returnFunction, mcfunctionClone);
            return returnFunction;
        };
        /**
         * Create a predicate.
         *
         * @param predicate The actual predicate. You must provide at least a `condition` for it to be valid.
         *
         * @example
         *
         * Predicate('is_raining', {
         *   condition: 'minecraft:weather_check',
         *   raining: true,
         * })
         */
        this.Predicate = (name, predicate, options) => {
            var _a;
            return (new _resources_1.PredicateInstance(this.datapack, this.getName(name), predicate, { onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.predicate, ...options }));
        };
        /** Create a recipe. */
        this.Recipe = (name, recipe, options) => {
            var _a;
            return (new _resources_1.RecipeInstance(this.datapack, this.getName(name), recipe, { onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.recipe, ...options }));
        };
        /** Create a tag. */
        this.Tag = (type, name, values = [], replace, options) => {
            var _a;
            return (new _resources_1.TagInstance(this.datapack, type, this.getName(name), values, replace, { onConflict: (_a = this.onConflict) === null || _a === void 0 ? void 0 : _a.tag, ...options }));
        };
        this.datapack = datapack;
        this.namespace = basePath.namespace;
        // Copy onConflict into an object
        const onConflict = basePath.onConflict ? { ...basePath.onConflict } : undefined;
        // Apply default
        if (onConflict === null || onConflict === void 0 ? void 0 : onConflict.default) {
            (_a = onConflict.advancement) !== null && _a !== void 0 ? _a : (onConflict.advancement = onConflict.default);
            (_b = onConflict.lootTable) !== null && _b !== void 0 ? _b : (onConflict.lootTable = onConflict.default);
            (_c = onConflict.mcFunction) !== null && _c !== void 0 ? _c : (onConflict.mcFunction = onConflict.default);
            (_d = onConflict.predicate) !== null && _d !== void 0 ? _d : (onConflict.predicate = onConflict.default);
            (_e = onConflict.recipe) !== null && _e !== void 0 ? _e : (onConflict.recipe = onConflict.default);
            (_f = onConflict.tag) !== null && _f !== void 0 ? _f : (onConflict.tag = onConflict.default);
        }
        this.onConflict = onConflict;
        // Remove forward & trailing slashes
        this.directory = (typeof basePath.directory === 'string' ? trimSlashes(basePath.directory) : undefined);
    }
    /** Validates & crafts the name of a resource. */
    getName(name) {
        var _a;
        if (this.namespace !== undefined && name.includes(':')) {
            throw new Error('Cannot define namespace under a base path.');
        }
        const resourcePath = this.datapack.getResourcePath(name);
        // Find the new path
        const path = [this.directory, ...resourcePath.fullPath].filter((x) => x !== undefined).join('/');
        // Find the new namespace
        const namespace = (_a = this.namespace) !== null && _a !== void 0 ? _a : resourcePath.namespace;
        // Validate them both
        /**
         * A namespace should only contain the following symbols:
         *
         * 0123456789 (Numbers)
         * abcdefghijklmnopqrstuvwxyz (Lowercase letters)
         * _ (Underscore)
         * - (Hyphen/minus)
         */
        if (!namespace.match(/^[0-9a-z_-]+$/)) {
            throw new Error(`A namespace should only contain numbers, lowercase letters, underscores and hyphen/minus, and be at least 1 caracter long: got "${namespace}"`);
        }
        /**
         * For resources:
         * You can name anything (recipes, advancements, etc) whatever name you like, but these are the only officially supported symbols:
         *
         * 0123456789 (Numbers)
         * abcdefghijklmnopqrstuvwxyz (Lowercase letters)
         * _ (Underscore)
         * / (Forward slash, directory separator)
         * . (Period)
         * - (Hyphen/minus)
         */
        if (!path.length) {
            throw new Error('Empty name is not allowed.');
        }
        if (!path.match(/^[0-9a-z_\-/.]+$/)) {
            throw new Error(`Resources names can only contain numbers, lowercase letters, underscores, forward slash, period, and hyphens: got "${path}"`);
        }
        // Two consecutive dots are not allowed (Minecraft won't recognize the function)
        if (path.includes('..')) {
            throw new Error(`Resources names cannot inclue two consecutive dots: got "${path}"`);
        }
        if (!this.namespace && !name.includes(':')) {
            // No namespace has been provided, directly return the path.
            return path;
        }
        return `${namespace}:${path}`;
    }
}
exports.BasePathClass = BasePathClass;
