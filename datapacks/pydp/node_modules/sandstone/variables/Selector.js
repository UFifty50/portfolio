"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectorClass = void 0;
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/ban-types */
const NBTs_1 = require("./NBTs");
const parsers_1 = require("./parsers");
const abstractClasses_1 = require("./abstractClasses");
// Returns the string representation of a score argument. `{ myScore: [0, null] } => {myScore=0..}`, `{ myScore: [-Infinity, 5] } => {myScore='..5'}`, 8 => '8'
function parseScore(scores) {
    return `{${Object.entries(scores).map(([scoreName, value]) => [scoreName, parsers_1.rangeParser(value)].join('=')).join(', ')}}`;
}
// Returns the string representation of advancements
function parseAdvancements(advancements) {
    return `{${Object.entries(advancements).map(([advancementName, value]) => {
        if (typeof value === 'boolean') {
            return [advancementName, value].join('=');
        }
        return [advancementName, parseAdvancements(value)].join('=');
    }).join(', ')}}`;
}
class SelectorClass extends abstractClasses_1.ComponentClass {
    constructor(commandsRoot, target, selectorArguments) {
        super();
        // Custom actions //
        /**
         * List all scores of this entity.
         */
        this.listScores = () => {
            this.commandsRoot.scoreboard.players.list(this.toString());
        };
        this.commandsRoot = commandsRoot;
        this.target = target;
        this.arguments = selectorArguments !== null && selectorArguments !== void 0 ? selectorArguments : {};
    }
    _toMinecraftCondition() {
        return { value: ['if', 'entity', this] };
    }
    toString() {
        if (!Object.keys(this.arguments).length) {
            return this.target;
        }
        const result = [];
        if (this.arguments) {
            const args = { ...this.arguments };
            const modifiers = {
                // Parse scores
                scores: (scores) => result.push(['scores', parseScore(scores)]),
                nbt: (nbt) => result.push(['nbt', NBTs_1.nbtParser(nbt)]),
                // Parse advancements
                advancements: (advancements) => result.push(['advancements', parseAdvancements(advancements)]),
                // Parse potentially multiple tags
                tag: (tag) => {
                    const tags = Array.isArray(tag) ? tag : [tag];
                    result.push(...tags.map((tag_) => ['tag', tag_]));
                },
                // Parse potentially multiple gamemodes
                gamemode: (gamemode) => {
                    const gamemodes = Array.isArray(gamemode) ? gamemode : [gamemode];
                    result.push(...gamemodes.map((gamemode_) => ['gamemode', gamemode_]));
                },
                // Parse potentially multiple predicates
                predicate: (predicate) => {
                    const predicates = Array.isArray(predicate) ? predicate : [predicate];
                    result.push(...predicates.map((pred) => ['predicate', pred]));
                },
                // Handle boolean values for teams
                team: (team) => {
                    let teamRepr;
                    if (team === true) {
                        teamRepr = '!';
                    }
                    else if (team === false) {
                        teamRepr = '';
                    }
                    else {
                        teamRepr = team;
                    }
                    result.push(['team', teamRepr]);
                },
                distance: (range_) => result.push(['distance', parsers_1.rangeParser(range_)]),
            };
            for (const [baseName, modifier] of Object.entries(modifiers)) {
                const name = baseName;
                const value = args[name];
                if (value !== undefined) {
                    modifier(value);
                    delete args[name];
                }
            }
            Object.entries(args).forEach(([key, value]) => {
                if (value !== undefined) {
                    result.push([key, value.toString()]);
                }
            });
        }
        return `${this.target}[${result.map(([key, value]) => `${key}=${value}`).join(', ')}]`;
    }
    _toChatComponent() {
        return {
            selector: this.toString(),
        };
    }
    toJSON() {
        return this.toString();
    }
}
exports.SelectorClass = SelectorClass;
