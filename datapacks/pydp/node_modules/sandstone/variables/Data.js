"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataPointInstance = exports.DataInstance = exports.TargetlessDataPointInstance = exports.TargetlessDataInstance = void 0;
const abstractClasses_1 = require("./abstractClasses");
const NBTs_1 = require("./NBTs");
const Score_1 = require("./Score");
function pathToString(path) {
    let result = '';
    for (const p of path) {
        if (typeof p === 'string') {
            if (result.length > 0) {
                result += '.';
            }
            result += p;
        }
        else {
            result += NBTs_1.nbtParser(p);
        }
    }
    return result;
}
class TargetlessDataInstance {
    constructor(datapack, type) {
        this.target = (target) => new DataInstance(this.datapack, this.type, target);
        this.select = (...path) => new TargetlessDataPointInstance(this.datapack, this.type, path);
        this.datapack = datapack;
        this.type = type;
    }
}
exports.TargetlessDataInstance = TargetlessDataInstance;
class TargetlessDataPointInstance {
    constructor(datapack, type, path) {
        this.target = (target) => new DataPointInstance(this.datapack, this.type, target, [this.path]);
        this.select = (...path) => new TargetlessDataPointInstance(this.datapack, this.type, [this.path, ...path]);
        this.datapack = datapack;
        this.type = type;
        this.path = pathToString(path);
    }
}
exports.TargetlessDataPointInstance = TargetlessDataPointInstance;
class DataInstance {
    constructor(datapack, type, target) {
        /**
         * Merge the given NBT to the current target.
         */
        this.merge = (value) => {
            this.datapack.commandsRoot.data.merge[this.type](this.currentTarget, value);
        };
        this.target = (target) => new DataInstance(this.datapack, this.type, target);
        this.select = (...path) => new DataPointInstance(this.datapack, this.type, this.currentTarget, path);
        this.datapack = datapack;
        this.type = type;
        this.currentTarget = target;
    }
}
exports.DataInstance = DataInstance;
class DataPointInstance extends abstractClasses_1.ConditionTextComponentClass {
    constructor(datapack, type, target, path) {
        super();
        this.target = (target) => new DataPointInstance(this.datapack, this.type, target, [this.path]);
        this.select = (...path) => new DataPointInstance(this.datapack, this.type, this.currentTarget, [this.path, ...path]);
        this.modify = (cb, value) => {
            const data = cb(this.datapack.commandsRoot.data.modify[this.type](this.currentTarget, this.path));
            // The value is another Data Point
            if (value instanceof DataPointInstance) {
                data.from[value.type](value.currentTarget, value.path);
                return;
            }
            // The value is a NBT
            data.value(value);
        };
        this.executeStore = (storeType, scale) => this.datapack.commandsRoot.execute.store.result[this.type](this.currentTarget, this.path, storeType, scale);
        this.set = (value, storeType, scale = 1) => {
            if (value instanceof Score_1.Score) {
                this.executeStore(storeType, scale).run.scoreboard.players.get(value.target, value.objective);
                return;
            }
            this.modify((data) => data.set, value);
        };
        /**
         * Set the data point to the given NBT.
         */
        this.merge = (value) => this.modify((data) => data.merge, value);
        /**
         * Append the given NBT to the current data point.
         */
        this.append = (value) => this.modify((data) => data.append, value);
        /**
         * Prepend the given NBT to the current data point.
         */
        this.prepend = (value) => this.modify((data) => data.prepend, value);
        /**
         * Insert the given NBT to the given index of the current data point.
         */
        this.insert = (value, index) => this.modify((data) => data.insert(index), value);
        /**
         * Remove the current NBT value.
         */
        this.remove = () => this.datapack.commandsRoot.data.remove[this.type](this.currentTarget, this.path);
        this._toMinecraftCondition = () => ({
            value: ['if', 'data', this.type, this.currentTarget, this.path],
        });
        this._toChatComponent = () => ({
            nbt: this.path,
            [this.type]: this.currentTarget,
        });
        this.datapack = datapack;
        this.type = type;
        this.path = pathToString(path);
        this.currentTarget = target;
    }
}
exports.DataPointInstance = DataPointInstance;
