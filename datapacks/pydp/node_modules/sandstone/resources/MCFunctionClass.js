"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCFunctionClass = void 0;
const env_1 = require("../env");
const utils_1 = require("../utils");
class MCFunctionClass {
    constructor(datapack, name, callback, options) {
        var _a;
        /**
         * Call the actual function overload. Returns different informations about it.
         */
        this.generate = () => {
            var _a;
            const { commandsRoot } = this.datapack;
            if (this.alreadyInitialized) {
                return undefined;
            }
            // Get the given tags
            let tags = (_a = this.options.tags) !== null && _a !== void 0 ? _a : [];
            // If it should run each tick, add it to the tick.json function
            const { runEach: runEachDelay } = this.options;
            if (runEachDelay !== undefined) {
                if (typeof runEachDelay === 'number' && runEachDelay < 0) {
                    throw new Error(`\`runEach\` argument must be greater than 0, got ${runEachDelay}`);
                }
                if (this.options.runOnLoad !== false) {
                    // If run on load, call it directly
                    tags = [...tags, 'minecraft:load'];
                }
            }
            else {
                // If runEachTick is specified, add to minecraft:tick
                if (this.options.runEachTick) {
                    tags = [...tags, 'minecraft:tick'];
                }
                // Idem for load
                if (this.options.runOnLoad) {
                    tags = [...tags, 'minecraft:load'];
                }
            }
            for (const tag of tags) {
                if (typeof tag === 'string') {
                    this.datapack.addFunctionToTag(this.name, tag);
                }
                else {
                    tag.values.push(this.name);
                }
            }
            const previousFunction = this.datapack.currentFunction;
            // Choose the conflict strategy
            let onConflict;
            let previousResource;
            if (this.onConflict === 'append' || this.onConflict === 'prepend') {
                onConflict = (oldFunc, newFunc) => {
                    previousResource = oldFunc;
                    newFunc.children = oldFunc.children;
                    return newFunc;
                };
            }
            else {
                onConflict = this.onConflict;
            }
            const resource = this.generateResource(onConflict);
            this.datapack.currentFunction = resource;
            const result = this.callback();
            // If the command was scheduled to run each n ticks, add the /schedule command
            if (runEachDelay) {
                this.datapack.commandsRoot.schedule.function(this.name, runEachDelay, 'append');
            }
            const afterCall = () => {
                var _a, _b;
                // If there is an unfinished command, register it
                commandsRoot.register(true);
                if (this.onConflict === 'append') {
                    resource.commands = [...((_a = previousResource === null || previousResource === void 0 ? void 0 : previousResource.commands) !== null && _a !== void 0 ? _a : []), ...resource.commands];
                }
                if (this.onConflict === 'prepend' && previousResource) {
                    resource.commands = [...resource.commands, ...((_b = previousResource === null || previousResource === void 0 ? void 0 : previousResource.commands) !== null && _b !== void 0 ? _b : [])];
                }
                // Then back to the previous one
                this.datapack.currentFunction = previousFunction;
            };
            if (utils_1.isPromise(result)) {
                return result.then(afterCall);
            }
            return afterCall();
        };
        this.call = () => {
            this.datapack.commandsRoot.functionCmd(this.name);
        };
        this.scheduleFunction = (delay, type) => {
            this.datapack.commandsRoot.schedule.function(this.name, delay, type);
        };
        this.clearSchedule = () => {
            this.datapack.commandsRoot.schedule.clear(this.name);
        };
        this.schedule = (() => {
            const scheduleFunction = this.scheduleFunction;
            scheduleFunction.clear = this.clearSchedule;
            return scheduleFunction;
        })();
        this.toString = () => this.name;
        this.toJSON = this.toString;
        options = options !== null && options !== void 0 ? options : {};
        this.options = { lazy: false, debug: process.env.NODE_ENV === 'development', ...options };
        this.alreadyInitialized = false;
        this.callback = callback;
        this.datapack = datapack;
        this.onConflict = (_a = options.onConflict) !== null && _a !== void 0 ? _a : env_1.CONFLICT_STRATEGIES.MCFUNCTION;
        // We "reserve" the folder by creating an empty folder there. It can be later changed to be a resource.
        const functionsPaths = datapack.getResourcePath(name);
        this.name = functionsPaths.fullName;
        this.path = functionsPaths.fullPathWithNamespace;
    }
    generateResource(strategy) {
        const resource = this.datapack.resources.addResource('functions', {
            children: new Map(), isResource: true, path: this.path, commands: [],
        }, strategy);
        return resource;
    }
}
exports.MCFunctionClass = MCFunctionClass;
