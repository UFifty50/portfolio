import { ResourceInstance } from "./Resource";
import type { AdvancementJSON, MultiplePlayersArgument } from "../arguments/index";
import type { BASIC_CONFLICT_STRATEGIES } from "../generalTypes";
import type { Datapack } from "../datapack/index";
export declare type AdvancementOptions = {
    /**
     * What to do if an Advancement has the same name.
     *
     * - `throw`: Throw an error.
     * - `replace`: Replace silently the old Advancement with the new one.
     * - `ignore`: Keep silently the old Advancement, discarding the new one.
     */
    onConflict?: BASIC_CONFLICT_STRATEGIES;
};
export declare class AdvancementInstance<CriteriaNames extends string = string> extends ResourceInstance {
    advancementJSON: AdvancementJSON<CriteriaNames>;
    constructor(datapack: Datapack, name: string, advancement: AdvancementJSON<CriteriaNames>, options?: AdvancementOptions);
    /**
     * Grant this advancement to the players.
     */
    grant(players: MultiplePlayersArgument, criterion?: CriteriaNames): void;
    /**
     * Revoke this advancement from the players.
     */
    revoke(players: MultiplePlayersArgument, criterion?: CriteriaNames): void;
    /**
     * Grant this advancement and all its parent advancements to the players.
     * Think of specifying everything from the start *until* that advancement.
     *
     * The exact order the operation is carried out in is: `parent > parent's parent > ... > root > this advancement.`
     */
    grantUntilThis(players: MultiplePlayersArgument): void;
    /**
     * Revoke this advancement and all its parent advancements from the players.
     * Think of specifying everything from the start *until* that advancement.
     *
     * The exact order the operation is carried out in is: `parent > parent's parent > ... > root > this advancement.`
     */
    revokeUntilThis(players: MultiplePlayersArgument): void;
    /**
     * Grant this advancement and all its children advancements to the players.
     * Think of specifying everything *from* that advancement to the end.
     *
     * The exact order the operation is carried out in is specified `advancement > child > child's child > ...`.
     * When it operates on a child that branches, it iterates through all its children before continuing.
     */
    grantFromThis(players: MultiplePlayersArgument): void;
    /**
     * Revoke this advancement and all its children advancements from the players.
     * Think of specifying everything *from* that advancement to the end.
     *
     * The exact order the operation is carried out in is specified `advancement > child > child's child > ...`.
     * When it operates on a child that branches, it iterates through all its children before continuing.
     */
    revokeFromThis(players: MultiplePlayersArgument): void;
    /**
     * Grant this advancement, all its parent advancements, and all its children advancements to the players.
     * Think of specifying everything through the specified advancement, going both backwards and forwards.
     *
     * The exact order the operation is as if the command were executed with `until` specified, then with `from` specified:
     * `parent > parent's parent > ... > root > specified advancement > child > child's child > ...`
     */
    grantThroughThis(players: MultiplePlayersArgument): void;
    /**
     * Revoke this advancement, all its parent advancements, and all its children advancements from the players.
     * Think of specifying everything through the specified advancement, going both backwards and forwards.
     *
     * The exact order the operation is as if the command were executed with `until` specified, then with `from` specified:
     * `parent > parent's parent > ... > root > specified advancement > child > child's child > ...`
     */
    revokeThroughThis(players: MultiplePlayersArgument): void;
}
