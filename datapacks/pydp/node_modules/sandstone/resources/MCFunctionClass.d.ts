import type { TimeArgument } from "../arguments/index";
import type { BASIC_CONFLICT_STRATEGIES } from "../generalTypes";
import type { Datapack } from "../datapack/index";
import type { MCFunctionInstance } from "../datapack/Datapack";
import type { ResourcePath } from "../datapack/resourcesTree";
import type { TagInstance } from "./Tag";
export declare type MCFunctionOptions = {
    /**
     * If true, then the function will only be created if it is called from another function.
     */
    lazy?: boolean;
    /**
     * Whether to activate debugging features for the function.
     *
     * For the moment, it only adds some comments detailling what each function options & arguments are.
     *
     * It defaults to `true` if the environment variable NODE_ENV is set to `development`, else it defaults to `false`
     */
    debug?: boolean;
    /**
     * Whether the function should run when the datapack loads.
     *
     * Defaults to `true` if `runEach` is specified, else `false`.
     */
    runOnLoad?: boolean;
    /**
     * What to do if another MCFunction has the same name.
     *
     * - `throw`: Throw an error.
     * - `replace`: Replace silently the old MCFunction with the new one.
     * - `ignore`: Keep silently the old MCFunction, discarding the new one.
     * - `warn`: Logs a warning to the console.
     * - `append`: Append the commands of the new MCFunction on the bottom of the new one.
     * - `prepend`: Prepend the commands of the new MCFunction on the top of the new one.
     */
    onConflict?: BASIC_CONFLICT_STRATEGIES | 'append' | 'prepend';
    /**
     * The function tags to put this function in.
     */
    tags?: readonly (string | TagInstance<'functions'>)[];
} & ({
    /**
     * Whether the function should run each tick.
     */
    runEachTick?: boolean;
} | {
    /**
     * If specified, the function will run every given time.
     *
     * If `runOnLoad` is unspecified or `true`, then it will run on load too.
     *
     * If `runOnLoad` is `false`, you will have to manually start it.
     *
     * You can stop the automatic scheduling by running `theFunction.clearSchedule()`.
     *
     * @example
     *
     * // Run each 5 ticks, including on data pack load.
     * {
     *   runEach: 5,
     * }
     *
     * // Run each 5 ticks, but wait 5 ticks before data pack loads for 1st execution.
     * {
     *   runEach: 5,
     *   runOnLoad: false,
     * }
     *
     * // Run each 8 seconds
     * {
     *   runEach: '8s'
     * }
     */
    runEach?: TimeArgument;
});
export declare class MCFunctionClass<R extends void | Promise<void> = void | Promise<void>> {
    name: string;
    path: ResourcePath;
    options: MCFunctionOptions;
    alreadyInitialized: boolean;
    datapack: Datapack;
    onConflict: NonNullable<MCFunctionOptions['onConflict']>;
    callback: () => R;
    constructor(datapack: Datapack, name: string, callback: (this: MCFunctionInstance) => R, options?: MCFunctionOptions);
    private generateResource;
    /**
     * Call the actual function overload. Returns different informations about it.
     */
    generate: () => R;
    call: () => void;
    private scheduleFunction;
    private clearSchedule;
    schedule: ((delay: TimeArgument, type?: "replace" | "append" | undefined) => void) & {
        clear: () => void;
    };
    toString: () => string;
    toJSON: () => string;
}
