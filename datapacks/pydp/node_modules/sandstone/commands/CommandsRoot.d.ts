import { AdvancementCommand, Bossbar, DataCommand, DatapackCommand, Debug, Effect, ExecuteWithRun, Experience, Forceload, Loot, RecipeCommand, Item, Schedule, Scoreboard, Team, Time, Weather, WorldBorder } from "./implementations/index";
import type { BIOMES, BLOCKS, Coordinates, ENTITY_TYPES, GAMEMODES, GAMERULES, ITEMS, JSONTextComponent, MessageOrSelector, MultipleEntitiesArgument, MultiplePlayersArgument, RootNBT, Rotation, SingleEntityArgument, SinglePlayerArgument, SOUND_EVENTS, SOUND_SOURCES, STRUCTURES } from "../arguments/index";
import type { LiteralUnion } from "../generalTypes";
import type Datapack from "../datapack/Datapack";
import type { CommandArgs } from "../datapack/minecraft";
export declare class CommandsRoot {
    Datapack: Datapack;
    /**
     * The state of the current execute command.
     * outside: we aren't in an execute command
     * inside : we are in an execute subcommand
     * after  : we are after the `run` part of an execute command
     */
    executeState: 'outside' | 'inside' | 'after';
    executable: boolean;
    arguments: CommandArgs;
    commandsRoot: CommandsRoot;
    constructor(datapack: Datapack);
    reset(): void;
    /**
     * Registers the current command.
     *
     * @param soft If true, then it allows to try to register a command when we don't know if it is needed.
     * Sometimes, is is possible a command needs to be registered, or maybe it's not. Then a soft register is necessary.
     */
    register: (soft?: boolean) => void;
    /**
     * Add some arguments to the current ones, then registers them.
     * It will explicitely set the resulting command as executable.
     */
    addAndRegister: (...args: CommandArgs) => void;
    /** COMMANDS */
    advancement: AdvancementCommand;
    attribute: (target: SingleEntityArgument, attribute: string) => import("./implementations/index").AttributeOperation;
    bossbar: Bossbar;
    /**
     * Clears items from player inventory, including items being dragged by the player.
     *
     * @param targets Specifies the player(s) whose items are cleared.
     * If not specified, defaults to the player who executes the command.
     *
     * @param item Specifies the item to be cleared. If not specified, all items are cleared.
     *
     * @param maxCount Specifies the maximum number of items to be cleared.
     *
     * If not specified, all items that match `item` are cleared.
     *
     * If `0`, instead of clearing of items, detectes and queries the amount of specified items.
     */
    clear: (targets?: MultiplePlayersArgument | undefined, item?: LiteralUnion<ITEMS> | undefined, maxCount?: number | undefined) => void;
    clone: (begin: Coordinates, end: Coordinates, destination: Coordinates) => import("./implementations/index").CloneOptions;
    /**
     * Adds a comment, starting with a `# `, to the function.
     */
    comment: (...comments: unknown[]) => void;
    data: DataCommand;
    datapack: DatapackCommand;
    debug: Debug;
    defaultgamemode: (mode: GAMEMODES) => void;
    difficulty: (difficulty?: import("../arguments/index").DIFFICULTIES | undefined) => void;
    effect: Effect;
    enchant: (targets: MultipleEntitiesArgument, enchantment: LiteralUnion<import("../arguments/index").ENCHANTMENTS>, level?: number | undefined) => void;
    get execute(): Omit<ExecuteWithRun<CommandsRoot>, 'run' | 'runOne'>;
    xp: Experience;
    fill: (from: Coordinates, to: Coordinates, block: LiteralUnion<BLOCKS>) => import("./implementations/index").FillArguments;
    forceload: Forceload;
    functionCmd: (functionName: string | import("../index").TagInstance<"functions">) => void;
    /**
     * Sets a player's game mode.
     *
     * @param gamemode Specifies the new game mode. Must be one of the following:
     * - `survival` for survival mode
     * - `creative` for creative mode
     * - `adventure` for adventure mode
     * - `spectator` for spectator modeâ€Œ
     *
     * @param targets Specifies the target(s). If not specified, defaults to the player who executes the command.
     */
    gamemode: (gamemode: GAMEMODES, targets?: MultiplePlayersArgument | undefined) => void;
    gamerule: (gamerule: LiteralUnion<GAMERULES>, value?: number | boolean | undefined) => void;
    /**
     * Gives an item to one or more players.
     *
     * @param targets Specifies the target(s) to give item(s) to.
     *
     * @param item Specifies the item to give.
     *
     * @param count Specifies the number of items to give. If not specified, defaults to `1`.
     */
    give: (targets: MultiplePlayersArgument, item: LiteralUnion<ITEMS>, count?: number | undefined) => void;
    /**
     * Shows usages for one command, or lists of commands.
     *
     * @param command_ Specifies the command name to provide help for.
     * Entering more specific parameters of that command is allowed.
     *
     * If unspecified, lists all commands.
     *
     * @param parameters More specific parameters of the command.
     */
    help: (command_?: LiteralUnion<"list" | "trigger" | "xp" | "advancement" | "recipe" | "schedule" | "item" | "tag" | "weather" | "team" | "gamemode" | "execute" | "attribute" | "bossbar" | "clone" | "data" | "datapack" | "debug" | "defaultgamemode" | "difficulty" | "effect" | "give" | "clear" | "enchant" | "scoreboard" | "comment" | "experience" | "fill" | "functionCmd" | "forceload" | "gamerule" | "help" | "kill" | "locate" | "locatebiome" | "loot" | "me" | "msg" | "particle" | "playsound" | "raw" | "reload" | "say" | "seed" | "setblock" | "setidletimeout" | "setworldspawn" | "spawnpoint" | "spectate" | "spreadplayers" | "stopsound" | "summon" | "teammsg" | "teleport" | "tellraw" | "time" | "title" | "w" | "worldborder" | "tm" | "tp" | "tell"> | undefined, ...parameters: string[]) => void;
    /**
     * Kills entities (players, mobs, items, etc.).
     *
     * @param targets Specifies the target(s) to kill. If not specified, defaults to the executor who executed the command.
     */
    kill: (targets?: MultipleEntitiesArgument | undefined) => void;
    /**
     * Shows the names of all currently-connected players.
     *
     * @param uuid Whether to show player UUIDs alongside names. Defaults to false.
     */
    list: (uuids?: boolean | undefined) => void;
    /**
     * Displays the coordinates for the closest generated structure of a given type in the chat for the player who executed the command.
     *
     * @param structure Specifies the structure to locate.
     */
    locate: (structure: LiteralUnion<STRUCTURES>) => void;
    /**
     * Displays the coordinates for the closest biome of a given biome ID in the chat for the player who executed the command.
     *
     * @param biome Specifies the biome to be located.
     */
    locatebiome: (biome: LiteralUnion<BIOMES>) => void;
    loot: Loot;
    /**
     * Displays a message about yourself.
     *
     * @param actions Specifies the messages to display. They will be joined with a whitespace.
     *
     * Each action can be a message or a selector.
     * The game replaces entity selectors in the message with the list of selected entities' names,
     * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
     */
    me: (...actions: string[]) => void;
    particle: ((name: "minecraft:lava" | "minecraft:mycelium" | "minecraft:barrier" | "minecraft:end_rod" | "minecraft:composter" | "minecraft:flame" | "minecraft:dolphin" | "minecraft:elder_guardian" | "minecraft:witch" | "minecraft:dragon_breath" | "minecraft:totem_of_undying" | "minecraft:ambient_entity_effect" | "minecraft:angry_villager" | "minecraft:bubble" | "minecraft:cloud" | "minecraft:crit" | "minecraft:damage_indicator" | "minecraft:dripping_lava" | "minecraft:falling_lava" | "minecraft:landing_lava" | "minecraft:dripping_water" | "minecraft:falling_water" | "minecraft:effect" | "minecraft:enchanted_hit" | "minecraft:enchant" | "minecraft:entity_effect" | "minecraft:explosion_emitter" | "minecraft:explosion" | "minecraft:firework" | "minecraft:fishing" | "minecraft:soul_fire_flame" | "minecraft:soul" | "minecraft:flash" | "minecraft:happy_villager" | "minecraft:heart" | "minecraft:instant_effect" | "minecraft:item_slime" | "minecraft:item_snowball" | "minecraft:large_smoke" | "minecraft:note" | "minecraft:poof" | "minecraft:portal" | "minecraft:rain" | "minecraft:smoke" | "minecraft:sneeze" | "minecraft:spit" | "minecraft:squid_ink" | "minecraft:sweep_attack" | "minecraft:underwater" | "minecraft:splash" | "minecraft:bubble_pop" | "minecraft:current_down" | "minecraft:bubble_column_up" | "minecraft:nautilus" | "minecraft:campfire_cosy_smoke" | "minecraft:campfire_signal_smoke" | "minecraft:dripping_honey" | "minecraft:falling_honey" | "minecraft:landing_honey" | "minecraft:falling_nectar" | "minecraft:ash" | "minecraft:crimson_spore" | "minecraft:warped_spore" | "minecraft:dripping_obsidian_tear" | "minecraft:falling_obsidian_tear" | "minecraft:landing_obsidian_tear" | "minecraft:reverse_portal" | "minecraft:white_ash", pos?: Coordinates | undefined, delta?: [deltaX: number, deltaY: number, deltaZ: number] | undefined, speed?: number | undefined, count?: number | undefined, mode?: "normal" | "force" | undefined, viewers?: MultiplePlayersArgument | undefined) => void) & ((name: "minecraft:dust", colors: [red: number, green: number, blue: number, size: number], size: number, pos?: Coordinates | undefined, delta?: [deltaX: number, deltaY: number, deltaZ: number] | undefined, speed?: number | undefined, count?: number | undefined, mode?: "normal" | "force" | undefined, viewers?: MultiplePlayersArgument | undefined) => void) & ((name: "minecraft:block" | "minecraft:falling_dust", block: LiteralUnion<BLOCKS>, pos?: Coordinates | undefined, delta?: [deltaX: number, deltaY: number, deltaZ: number] | undefined, speed?: number | undefined, count?: number | undefined, mode?: "normal" | "force" | undefined, viewers?: MultiplePlayersArgument | undefined) => void) & ((name: "minecraft:item", item: LiteralUnion<ITEMS>, pos?: Coordinates | undefined, delta?: [deltaX: number, deltaY: number, deltaZ: number] | undefined, speed?: number | undefined, count?: number | undefined, mode?: "normal" | "force" | undefined, viewers?: MultiplePlayersArgument | undefined) => void);
    /**
     * Plays a specified sound at a player, in a location, and in a specific volume and pitch.
     *
     * @param sound Specifies the sound to play.
     *
     * A sound event may be affiliated with multiple sounds, and the sound that is actually produced is chosen at random from them,
     * modified by their "weight", just as the game normally would.
     * For example, the `entity.pig.ambient` sound event plays one of several pig sounds at random,
     * because the event has multiple sounds associated with it.
     *
     * Resource packs may add their own events to `sounds.json`; the command successfully plays these.
     * File names are not used by this command; it strictly uses the events defined in `sounds.json`
     * (which may not even be similar to the original file names and paths),
     * and thus a resource pack adding new sound files must define events for them
     * (this is not necessary when replacing old sounds already defined in events).
     *
     * @param source Specifies the music category and options the sound falls under.
     *
     * @param targets Specifies the sound's target.
     */
    playsound: (sound: LiteralUnion<SOUND_EVENTS>, source: SOUND_SOURCES, targets: MultiplePlayersArgument, sourcePosition?: Coordinates | undefined, volume?: number | undefined, pitch?: number | undefined, minVolume?: number | undefined) => void;
    recipe: RecipeCommand;
    /**
     * Reloads the current data packs.
     *
     * If a data pack has invalid data (such as an invalid recipe format),
     * changes are not applied and the game continues using the previous data.[
     */
    reload: () => void;
    /**
     * A raw command. Can be used to create custom commands, for mods or plugins for example.
     *
     * @example
     * // A custom `mount` command, that takes a player and an entity as argument
     * const self = Selector(`@s`)
     * const nearestSkeleton = Selector(`@e`, { limit: 1, sort: 'nearest' })
     *
     * raw('mount', self, nearestSkeleton)
     */
    raw: (...args: unknown[]) => void;
    item: Item;
    /**
     * Sends a message in the chat.
     *
     * @param messages Specifies the messages to say.
     * All messages will be joined with a whitespace.
     *
     * Each message must be a plain text, or a target selectors.
     * The game replaces entity selectors in the message with the list of selected entities' names, which is formatted as "name1 and name2" for two entities,
     * or "name1, name2, ... and namen" for n entities.
     */
    say: (...messages: MessageOrSelector[]) => void;
    schedule: Schedule;
    scoreboard: Scoreboard;
    /** Displays the world seed. */
    seed: () => void;
    /**
     * Changes a block to another block.
     *
     * @param pos Specifies the position of the block to be changed.
     *
     * @param block Specifies the new block.
     *
     * @param type Specifies how to handle the block change. Must be one of:
     * - `destroy`: The old block drops both itself and its contents (as if destroyed by a player). Plays the appropriate block breaking noise.
     * - `keep`: Only air blocks are changed (non-air blocks are unchanged).
     * - `replace`: The old block drops neither itself nor any contents. Plays no sound.
     *
     * If not specified, defaults to `replace`.
     */
    setblock: (pos: Coordinates, block: LiteralUnion<BLOCKS>, type?: "replace" | "destroy" | "keep" | undefined) => void;
    /**
     * Sets the time before idle players are kicked from the server.
     *
     * @param minutes Specifies the idle kick timer.
     */
    setidletimeout: (minutes: number) => void;
    /**
     * Sets the world spawn.
     *
     * @param pos Specifies the coordinates of the world spawn. If not specified, defaults to the block position of the command's execution.
     *
     * @param angle Specified the yaw angle to spawn with. Defaults to the direction the executor is facing.
     */
    setworldspawn: (pos?: Coordinates | undefined, angle?: Rotation | undefined) => void;
    /**
     * Sets the spawn point for a player. You can now set your spawnpoint in the Nether and End.
     *
     * @param targets Specifies the player whose spawn point should be set.
     * If not specified, defaults to the command's executor.
     *
     * @param pos Specifies the coordinates of the player's new spawn point.
     * If not specified, defaults to the position of the command's executor in Java Edition.
     *
     * @param angle Specifies the yaw angle to spawn with. Defaults to the direction the executor is facing.
     */
    spawnpoint: (targets?: MultiplePlayersArgument | undefined, pos?: Coordinates | undefined, angle?: Rotation | undefined) => void;
    /**
     * Causes a player in Spectator mode to spectate another entity.
     *
     * @param targets Specifies the target to be spectated.
     *
     * @param player Specifies the spectating player. If unspecified, defaults to the executor.
     */
    spectate: (target: SinglePlayerArgument, player?: SingleEntityArgument | undefined) => void;
    spreadplayers: ((center: import("../arguments/index").ColumnCoordinates, spreadDistance: number, maxRange: number, respectTeams: boolean, targets: MultipleEntitiesArgument) => void) & ((center: import("../arguments/index").ColumnCoordinates, spreadDistance: number, maxRange: number, underHeight: number, respectTeams: boolean, targets: MultipleEntitiesArgument) => void);
    /**
     * Stops a given sound.
     *
     * @param targets Specifies the command's target.
     *
     * @param source Specifies which category in the Music & Sound options the sound falls under. If it is *, stop sound of all category.
     *
     * @param sound Specifies the sound to stop.
     */
    stopsound: (targets: MultiplePlayersArgument, source?: "*" | SOUND_SOURCES | undefined, sound?: LiteralUnion<SOUND_EVENTS> | undefined) => void;
    /**
     * Summons an entity.
     *
     * @param entity Specifies the entity to be summoned.
     *
     * @param pos Specifies the position to summon the entity. If not specified, defaults to the position of the command's execution.
     *
     * @param nbt Specifies the data tag for the entity.
     */
    summon: (entity: LiteralUnion<ENTITY_TYPES>, pos?: Coordinates | undefined, nbt?: RootNBT | undefined) => void;
    tag: (targets: MultipleEntitiesArgument) => import("./implementations/index").TagArguments;
    team: Team;
    /**
     * Specifies a message to send to team.
     *
     * @param messages Must be plain text messages.
     * Can include spaces as well as target selectors.
     * The game replaces entity selectors in the message with the list of selected entities' names,
     * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
     *
     * At least one message is necesarry.
     */
    tm: (messages_0: MessageOrSelector, ...messages_1: MessageOrSelector[]) => void;
    tp: ((destinationEntity: SingleEntityArgument) => void) & ((location: Coordinates) => void) & ((targets: MultipleEntitiesArgument, destinationEntity: SingleEntityArgument) => void) & ((targets: MultipleEntitiesArgument, location: Coordinates) => import("./implementations/index").TeleportFacing) & ((targets: MultipleEntitiesArgument, location: Coordinates, rotation: Rotation) => void);
    /**
     * Sends a private message to one or more players.
     * @param targets Specifies the player(s) to send the message to.
     * @param messages Specified the message to tell. They will be joined with whitespaces.
     * Can include target selectors.
     * The game replaces entity selectors in the message with the list of selected entities' names,
     * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
     */
    w: (targets: MultiplePlayersArgument, messages_0: MessageOrSelector, ...messages_1: MessageOrSelector[]) => void;
    tellraw: (targets: MultiplePlayersArgument, message: JSONTextComponent) => void;
    time: Time;
    title: (targets: MultiplePlayersArgument) => import("./implementations/index").TitleArguments;
    trigger: (objective: import("../arguments/index").ObjectiveArgument) => import("./implementations/index").TriggerArguments;
    weather: Weather;
    worldborder: WorldBorder;
    tell: (targets: MultiplePlayersArgument, messages_0: MessageOrSelector, ...messages_1: MessageOrSelector[]) => void;
    teammsg: (messages_0: MessageOrSelector, ...messages_1: MessageOrSelector[]) => void;
    teleport: ((destinationEntity: SingleEntityArgument) => void) & ((location: Coordinates) => void) & ((targets: MultipleEntitiesArgument, destinationEntity: SingleEntityArgument) => void) & ((targets: MultipleEntitiesArgument, location: Coordinates) => import("./implementations/index").TeleportFacing) & ((targets: MultipleEntitiesArgument, location: Coordinates, rotation: Rotation) => void);
    msg: (targets: MultiplePlayersArgument, messages_0: MessageOrSelector, ...messages_1: MessageOrSelector[]) => void;
    experience: Experience;
}
export default CommandsRoot;
