import type { ANCHORS, AXES, BLOCKS, COMPARISON_OPERATORS, Coordinates, DIMENSION_TYPES, MultipleEntitiesArgument, ObjectiveArgument, Range, Rotation, SingleEntityArgument } from "../../arguments/index";
import type * as commands from "../../commandsOnly";
import type { LiteralUnion } from "../../generalTypes";
import type { Flow } from "../../flow/index";
import type { ConditionClass } from "../../variables/index";
import type { DataPointInstance } from "../../variables/Data";
import type { Score } from "../../variables/Score";
import type { CommandsRoot } from "../CommandsRoot";
export declare type StoreType = 'byte' | 'short' | 'int' | 'long' | 'float' | 'double';
declare type CommandsRootLike = CommandsRoot | Flow;
declare class CommandLike<T extends CommandsRootLike> {
    protected commandsRoot: T;
    constructor(commandsRootLike: T);
}
declare class ExecuteSubcommand<T extends CommandsRootLike> extends CommandLike<T> {
    protected execute: InferExecute<T>;
    constructor(execute: InferExecute<T>);
}
export declare class ExecuteStoreArgs<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /**
     * Saves the final command's return value as tag data within a block entity.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * @param targetPos Position of target block
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value. Defaults to 1.
     */
    block: (targetPos: Coordinates, path: string, type: StoreType, scale?: number) => InferExecute<T>;
    /**
     * Saves the final command's return value in either a bossbar's current value or its maximum value.
     *
     * @param id ID of the bossbar to target for saving.
     *
     * @param type Whether to overwrite the bossbar's current value or its max value.
     */
    bossbar: (id: string, type: 'max' | 'value') => InferExecute<T>;
    /**
     * Save the final command's return value in one of an entity's data tags.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * Like the `/data` command, `/execute store <arguments>` cannot modify player NBT.
     *
     * @param target A single entity to store under.
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value. Defaults to 1.
     */
    entity: (target: SingleEntityArgument, path: string, type: StoreType, scale?: number) => InferExecute<T>;
    score: ((
    /**
     * Overrides `targets`' score on the given `objective` with the final command's return value.
     *
     * @param targets Specifies score holder(s) whose score is to be overridden.
     *
     * @param objective A scoreboard objective.
     */
    (targets: MultipleEntitiesArgument, objective: ObjectiveArgument) => InferExecute<T>) & (
    /**
     * Overrides the given player's score with the final command's return value.
     *
     * @param playerScore The player's score to override.
     */
    (playerScore: Score) => InferExecute<T>));
    /**
     * Uses the `path` within storage `target` to store the return value in.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * If the storage does not yet exist, it gets created.
     *
     * @param target Target storage container, as a namespaced ID.
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value. Defaults to 1.
     */
    storage: (target: string, path: string, type: StoreType, scale?: number) => InferExecute<T>;
}
export declare class ExecuteStore<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /** Store the final command's result value. */
    get result(): ExecuteStoreArgs<T>;
    /** Store the final command's success value. */
    get success(): ExecuteStoreArgs<T>;
}
export declare class ExecuteIfData<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /**
     * Checks whether the targeted block has any data for a given tag
     * @param pos Position of the block to be tested.
     * @param path Data tag to check for.
     */
    block: (pos: Coordinates, path: string) => InferExecute<T>;
    /**
     * Checks whether the targeted entity has any data for a given tag
     * @param target One single entity to be tested.
     * @param path Data tag to check for.
     */
    entity: (target: SingleEntityArgument, path: string) => InferExecute<T>;
    /**
     * Checks whether the targeted storage has any data for a given tag
     * @param source The storage to check in.
     * @param path Data tag to check for.
     */
    storage: (source: string, path: string) => InferExecute<T>;
}
declare type IfsAndUnlesses<T extends CommandsRootLike, E extends Execute<T>> = {
    ifBlock: (pos: Coordinates, block: LiteralUnion<BLOCKS>) => E;
    ifBlocks: (start: Coordinates, end: Coordinates, destination: Coordinates, scanMode: 'all' | 'masked') => E;
    ifData: ((data: DataPointInstance) => E) & ExecuteIfData<T>;
    ifEntity: (targets: MultipleEntitiesArgument) => E;
    ifPredicate: (predicate: string) => E;
    ifScore: (
    /**
     * Check a score against either another score or a given range.
     *
     * @param target A single score holder.
     *
     * @param objective The scoreboard objective to check under.
     *
     * @param operator The comparison operator to use.
     *
     * @param source A second score holder to compare against.
     *
     * @param sourceObjective  A scoreboard objective to compare against.
     */
    (target: SingleEntityArgument, targetObjective: ObjectiveArgument, operator: COMPARISON_OPERATORS, source: SingleEntityArgument, sourceObjective: ObjectiveArgument) => Execute<T>) & (
    /**
     * Check a score against either another score or a given range.
     *
     * @param target A single score holder.
     *
     * @param objective The scoreboard objective to check under.
     *
     * @param operator The comparison operator to use.
     *
     * @param range Range to compare score against.
     */
    (target: SingleEntityArgument, targetObjective: ObjectiveArgument, operator: 'matches', range: Range) => E);
};
declare type IfType<T extends CommandsRootLike, E extends Execute<T>> = {
    /**
     * Compares the block at a given position to a given block.
     *
     * @param pos Position of a target block to test.
     *
     * @param block A block to test against.
     */
    block: IfsAndUnlesses<T, E>['ifBlock'];
    /**
     * Compares the blocks in two equally sized volumes. Suceeds if both are identical.
     *
     * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
     *
     * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
     *
     * @param destination
     * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
     * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
     *
     * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
     */
    blocks: IfsAndUnlesses<T, E>['ifBlocks'];
    /** Checks whether the targeted block, entity or storage has any data for a given tag. */
    data: IfsAndUnlesses<T, E>['ifData'];
    /**
     * Checks whether one or more entities exist.
     *
     * @param targets The target entities to check.
     */
    entity: IfsAndUnlesses<T, E>['ifEntity'];
    /**
     * Checks whether the `predicate` evaluates to a positive result.
     *
     * @param predicate The predicate to test.
     */
    predicate: IfsAndUnlesses<T, E>['ifPredicate'];
    /**
     * Check a score against either another score or a given range.
     */
    score: IfsAndUnlesses<T, E>['ifScore'];
};
export declare class Execute<T extends CommandsRootLike> extends CommandLike<T> {
    /**
     * Updates the command's position, aligning to its current block position (an integer). Only applies along specified axes.
     * This is akin to flooring the coordinates – i.e. rounding them downwards. It updates the meaning of `~ ~ ~` and `^ ^ ^`.
     *
     * @param axes Any non-repeating combination of the characters 'x', 'y', and 'z'.
     */
    align: (axes: AXES) => this;
    /**
     * Stores the distance from the feet to the eyes of the entity that is executing the command in the anchor, which is part of the command context.
     * Effectively recentres `^ ^ ^` on either the eyes or feet, also changing the angle the `facing` sub-command works off of.
     *
     * @param anchor Whether to anchor the executed command to eye level or feet level
     */
    anchored: (anchor: ANCHORS) => this;
    /**
     * Sets the command sender to target entity, without changing position, rotation, dimension, or anchor
     *
     * @param targets Target entity/entities to become the new sender.
     */
    as: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command position, rotation, and dimension to match those of an entity/entities; does not change sender
     * @param targets Target entity/entities to match position, rotation, and dimension with
     */
    at: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
     *
     * @param pos Coordinate to rotate towards.
     */
    facing: (pos: Coordinates) => this;
    /**
     * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
     *
     * @param targets The target(s) to rotate towards.
     *
     * @param anchor Whether to point at the target's eyes or feet.
     */
    facingEntity: (targets: MultipleEntitiesArgument, anchor: ANCHORS) => this;
    /**
     * Sets the command dimension.
     *
     * @param dimension Name of the new execution dimension.
     */
    in: (dimension: LiteralUnion<DIMENSION_TYPES>) => this;
    /**
     * Sets the command position, without changing rotation or dimension.
     *
     * @param pos The new position.
     */
    positioned: (pos: Coordinates) => this;
    /**
     * Sets the command position, without changing rotation or dimension, by matching an entity's position.
     *
     * @param targets Target entity/entities to match position with.
     */
    positionedAs: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command rotation.
     *
     * @param rotation The desired rotation.
     *
     * First value is measured clockwise in degrees from due south (the +Z Axis), ranging [–180 to +180)
     * Second value is measured as declination from the horizon in degrees, ranging [–90 to +90] (straight up to straight down)
     *
     * Relative values can be used to specify a rotation relative to the current execution rotation.
     */
    rotated: (rotation: Rotation) => this;
    /**
     * Sets the command rotation, by matching an entity's rotation.
     *
     * @param targets Target entity/entities to match rotation with.
     */
    rotatedAs: (targets: MultipleEntitiesArgument) => this;
    private ifBlock;
    private unlessBlock;
    private ifBlocks;
    private unlessBlocks;
    private ifData;
    private unlessData;
    private ifEntity;
    private unlessEntity;
    private ifPredicate;
    private unlessPredicate;
    private ifScore;
    private unlessScore;
    private if_;
    /** Checks if the given condition is met. */
    get if(): ((condition: ConditionClass) => this) & IfType<T, this>;
    /** Checks if the given conditions is not met. */
    get unless(): Execute<T>['if'];
    protected register: () => void;
    /**
     * Store the final command's result or success value somewhere.
     * It first records the location to store in, and then stores in the location after all the commands are executed.
     *
     * Note that the return values of commands must be an integer. If a decimal, it is rounded down.
     */
    store: ExecuteStore<T>;
    /**
     * Runs a single command.
     */
    get run(): (T extends CommandsRoot ? Pick<T, keyof typeof commands> : T);
}
export declare class ExecuteWithRun<T extends CommandsRoot> extends Execute<T> {
    /**
     * Runs one or multiple commands.
     *
     * When giving a callback, if it only creates one command, and this command is safe to be inlined,
     * it will be inlined to avoid a useless function call.
     *
     * @example
     * // Run multiple commands
     * execute.as(`@a`).run(() => {
     *    give(`@s`, 'minecraft:diamond', 1)
     *    kill(`@s`)
     * })
     *
     * // Run a single command
     * execute.as(`@s`).run.give(`@s`, 'minecraft:diamond', 1)
     */
    get run(): (<R extends void | Promise<void>>(callback: () => R) => R) & (<R_1 extends void | Promise<void>>(name: string, callback: () => R_1) => R_1) & (T extends CommandsRoot ? Pick<T, "list" | "trigger" | "xp" | "advancement" | "recipe" | "schedule" | "item" | "tag" | "weather" | "team" | "gamemode" | "execute" | "attribute" | "bossbar" | "clone" | "data" | "datapack" | "debug" | "defaultgamemode" | "difficulty" | "effect" | "give" | "clear" | "enchant" | "scoreboard" | "comment" | "experience" | "fill" | "functionCmd" | "forceload" | "gamerule" | "help" | "kill" | "locate" | "locatebiome" | "loot" | "me" | "msg" | "particle" | "playsound" | "raw" | "reload" | "say" | "seed" | "setblock" | "setidletimeout" | "setworldspawn" | "spawnpoint" | "spectate" | "spreadplayers" | "stopsound" | "summon" | "teammsg" | "teleport" | "tellraw" | "time" | "title" | "w" | "worldborder" | "tm" | "tp" | "tell"> : T);
}
declare type InferExecute<T extends CommandsRootLike> = T extends CommandsRoot ? ExecuteWithRun<T> : Execute<T>;
export {};
