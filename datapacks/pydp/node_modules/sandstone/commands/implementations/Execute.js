"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteWithRun = exports.Execute = exports.ExecuteIfData = exports.ExecuteStore = exports.ExecuteStoreArgs = void 0;
const utils_1 = require("../../utils");
const _variables_1 = require("../../variables/index");
const decorators_1 = require("../decorators");
const executeConfig = {
    isRoot: false,
    hasSubcommands: true,
    executable: true,
    isExecuteSubcommand: true,
};
class CommandLike {
    constructor(commandsRootLike) {
        this.commandsRoot = commandsRootLike;
    }
}
class ExecuteSubcommand extends CommandLike {
    constructor(execute) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        super(execute.commandsRoot);
        this.execute = execute;
    }
}
function isRealCommandsRoot(commandsRootLike) {
    return Object.prototype.hasOwnProperty.call(commandsRootLike, 'register');
}
class ExecuteStoreArgs extends ExecuteSubcommand {
    constructor() {
        super(...arguments);
        /**
         * Saves the final command's return value as tag data within a block entity.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * @param targetPos Position of target block
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value. Defaults to 1.
         */
        this.block = (targetPos, path, type, scale = 1) => this.execute;
        /**
         * Saves the final command's return value in either a bossbar's current value or its maximum value.
         *
         * @param id ID of the bossbar to target for saving.
         *
         * @param type Whether to overwrite the bossbar's current value or its max value.
         */
        this.bossbar = (id, type) => this.execute;
        /**
         * Save the final command's return value in one of an entity's data tags.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * Like the `/data` command, `/execute store <arguments>` cannot modify player NBT.
         *
         * @param target A single entity to store under.
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value. Defaults to 1.
         */
        this.entity = (target, path, type, scale = 1) => this.execute;
        this.score = (...args) => this.execute;
        /**
         * Uses the `path` within storage `target` to store the return value in.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * If the storage does not yet exist, it gets created.
         *
         * @param target Target storage container, as a namespaced ID.
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value. Defaults to 1.
         */
        this.storage = (target, path, type, scale = 1) => this.execute;
    }
}
__decorate([
    decorators_1.command('block', { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "block", void 0);
__decorate([
    decorators_1.command('bossbar', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "bossbar", void 0);
__decorate([
    decorators_1.command('entity', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "entity", void 0);
__decorate([
    decorators_1.command('score', executeConfig),
    __metadata("design:type", Function)
], ExecuteStoreArgs.prototype, "score", void 0);
__decorate([
    decorators_1.command('storage', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "storage", void 0);
exports.ExecuteStoreArgs = ExecuteStoreArgs;
class ExecuteStore extends ExecuteSubcommand {
    /** Store the final command's result value. */
    get result() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('store', 'result');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.executeState = 'inside';
        }
        return new ExecuteStoreArgs(this.execute);
    }
    /** Store the final command's success value. */
    get success() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('store', 'success');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.executeState = 'inside';
        }
        return new ExecuteStoreArgs(this.execute);
    }
}
exports.ExecuteStore = ExecuteStore;
class ExecuteIfData extends ExecuteSubcommand {
    constructor() {
        super(...arguments);
        /**
         * Checks whether the targeted block has any data for a given tag
         * @param pos Position of the block to be tested.
         * @param path Data tag to check for.
         */
        this.block = (pos, path) => this.execute;
        /**
         * Checks whether the targeted entity has any data for a given tag
         * @param target One single entity to be tested.
         * @param path Data tag to check for.
         */
        this.entity = (target, path) => this.execute;
        /**
         * Checks whether the targeted storage has any data for a given tag
         * @param source The storage to check in.
         * @param path Data tag to check for.
         */
        this.storage = (source, path) => this.execute;
    }
}
__decorate([
    decorators_1.command('block', { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "block", void 0);
__decorate([
    decorators_1.command('entity', executeConfig),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "entity", void 0);
__decorate([
    decorators_1.command('storage', executeConfig),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "storage", void 0);
exports.ExecuteIfData = ExecuteIfData;
class Execute extends CommandLike {
    constructor() {
        super(...arguments);
        /**
         * Updates the command's position, aligning to its current block position (an integer). Only applies along specified axes.
         * This is akin to flooring the coordinates â€“ i.e. rounding them downwards. It updates the meaning of `~ ~ ~` and `^ ^ ^`.
         *
         * @param axes Any non-repeating combination of the characters 'x', 'y', and 'z'.
         */
        this.align = (axes) => this;
        /**
         * Stores the distance from the feet to the eyes of the entity that is executing the command in the anchor, which is part of the command context.
         * Effectively recentres `^ ^ ^` on either the eyes or feet, also changing the angle the `facing` sub-command works off of.
         *
         * @param anchor Whether to anchor the executed command to eye level or feet level
         */
        this.anchored = (anchor) => this;
        /**
         * Sets the command sender to target entity, without changing position, rotation, dimension, or anchor
         *
         * @param targets Target entity/entities to become the new sender.
         */
        this.as = (targets) => this;
        /**
         * Sets the command position, rotation, and dimension to match those of an entity/entities; does not change sender
         * @param targets Target entity/entities to match position, rotation, and dimension with
         */
        this.at = (targets) => this;
        /**
         * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
         *
         * @param pos Coordinate to rotate towards.
         */
        this.facing = (pos) => this;
        /**
         * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
         *
         * @param targets The target(s) to rotate towards.
         *
         * @param anchor Whether to point at the target's eyes or feet.
         */
        this.facingEntity = (targets, anchor) => this;
        /**
         * Sets the command dimension.
         *
         * @param dimension Name of the new execution dimension.
         */
        this.in = (dimension) => this;
        /**
         * Sets the command position, without changing rotation or dimension.
         *
         * @param pos The new position.
         */
        this.positioned = (pos) => this;
        /**
         * Sets the command position, without changing rotation or dimension, by matching an entity's position.
         *
         * @param targets Target entity/entities to match position with.
         */
        this.positionedAs = (targets) => this;
        /**
         * Sets the command rotation.
         *
         * @param rotation The desired rotation.
         *
         * First value is measured clockwise in degrees from due south (the +Z Axis), ranging [â€“180 to +180)
         * Second value is measured as declination from the horizon in degrees, ranging [â€“90 to +90] (straight up to straight down)
         *
         * Relative values can be used to specify a rotation relative to the current execution rotation.
         */
        this.rotated = (rotation) => this;
        /**
         * Sets the command rotation, by matching an entity's rotation.
         *
         * @param targets Target entity/entities to match rotation with.
         */
        this.rotatedAs = (targets) => this;
        this.ifBlock = (...args) => this;
        this.unlessBlock = (...args) => this;
        this.ifBlocks = (...args) => this;
        this.unlessBlocks = (...args) => this;
        this.ifData = () => {
            if (!this.commandsRoot.arguments.length) {
                this.commandsRoot.arguments.push('execute');
            }
            this.commandsRoot.arguments.push('if', 'data');
            if (isRealCommandsRoot(this.commandsRoot)) {
                this.commandsRoot.executable = true;
                this.commandsRoot.executeState = 'inside';
            }
            const result = (data) => {
                this.commandsRoot.arguments.push(data.type, data.currentTarget, data.path);
                return this;
            };
            return Object.assign(result, new ExecuteIfData(this));
        };
        this.unlessData = () => {
            if (!this.commandsRoot.arguments.length) {
                this.commandsRoot.arguments.push('execute');
            }
            this.commandsRoot.arguments.push('unless', 'data');
            if (isRealCommandsRoot(this.commandsRoot)) {
                this.commandsRoot.executable = true;
                this.commandsRoot.executeState = 'inside';
            }
            const result = (data) => {
                this.commandsRoot.arguments.push(data.type, data.currentTarget, data.path);
                return this;
            };
            return Object.assign(result, new ExecuteIfData(this));
        };
        this.ifEntity = (...args) => this;
        this.unlessEntity = (...args) => this;
        this.ifPredicate = (...args) => this;
        this.unlessPredicate = (...args) => this;
        this.ifScore = (...args) => this;
        this.unlessScore = (...args) => this;
        // For if & unless, we're using an intermediate command because the "real" arguments are in the `.value` property of the condition
        this.if_ = (...args) => this;
        this.register = () => { };
        /**
         * Store the final command's result or success value somewhere.
         * It first records the location to store in, and then stores in the location after all the commands are executed.
         *
         * Note that the return values of commands must be an integer. If a decimal, it is rounded down.
         */
        this.store = new ExecuteStore(this);
    }
    /** Checks if the given condition is met. */
    get if() {
        const result = Object.assign((condition) => this.if_(...condition._toMinecraftCondition().value), {
            block: this.ifBlock,
            blocks: this.ifBlocks,
            data: 0,
            entity: this.ifEntity,
            predicate: this.ifPredicate,
            score: this.ifScore,
        });
        Object.defineProperty(result, 'data', {
            get: this.ifData,
        });
        return result;
    }
    /** Checks if the given conditions is not met. */
    get unless() {
        const func = (condition) => {
            const args = condition._toMinecraftCondition().value;
            if (args[0] === 'if') {
                args[0] = 'unless';
            }
            else {
                args[0] = 'if';
            }
            return this.if_(...args);
        };
        const result = Object.assign(func, {
            block: this.unlessBlock,
            blocks: this.unlessBlocks,
            data: 0,
            entity: this.unlessEntity,
            predicate: this.unlessPredicate,
            score: this.unlessScore,
        });
        Object.defineProperty(result, 'data', {
            get: this.unlessData,
        });
        return result;
    }
    /**
     * Runs a single command.
     */
    get run() {
        this.commandsRoot.executeState = 'after';
        return this.commandsRoot;
    }
}
__decorate([
    decorators_1.command('align', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "align", void 0);
__decorate([
    decorators_1.command('anchored', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "anchored", void 0);
__decorate([
    decorators_1.command('as', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "as", void 0);
__decorate([
    decorators_1.command('at', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "at", void 0);
__decorate([
    decorators_1.command('facing', { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "facing", void 0);
__decorate([
    decorators_1.command(['facing', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "facingEntity", void 0);
__decorate([
    decorators_1.command('in', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "in", void 0);
__decorate([
    decorators_1.command('positioned', { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "positioned", void 0);
__decorate([
    decorators_1.command(['positioned', 'as'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "positionedAs", void 0);
__decorate([
    decorators_1.command('rotated', { ...executeConfig, parsers: { '0': _variables_1.rotationParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "rotated", void 0);
__decorate([
    decorators_1.command(['rotated', 'as'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "rotatedAs", void 0);
__decorate([
    decorators_1.command(['if', 'block'], { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "ifBlock", void 0);
__decorate([
    decorators_1.command(['unless', 'block'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessBlock", void 0);
__decorate([
    decorators_1.command(['if', 'blocks'], { ...executeConfig, parsers: { '0': _variables_1.coordinatesParser, '1': _variables_1.coordinatesParser, '2': _variables_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "ifBlocks", void 0);
__decorate([
    decorators_1.command(['unless', 'blocks'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessBlocks", void 0);
__decorate([
    decorators_1.command(['if', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "ifEntity", void 0);
__decorate([
    decorators_1.command(['unless', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessEntity", void 0);
__decorate([
    decorators_1.command(['if', 'predicate'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "ifPredicate", void 0);
__decorate([
    decorators_1.command(['unless', 'predicate'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessPredicate", void 0);
__decorate([
    decorators_1.command(['if', 'score'], {
        ...executeConfig,
        parsers: {
            '3': (arg, innerArgs) => {
                if (innerArgs[2] === 'matches') {
                    return _variables_1.rangeParser(arg);
                }
                return arg;
            },
        },
    }),
    __metadata("design:type", Object)
], Execute.prototype, "ifScore", void 0);
__decorate([
    decorators_1.command(['unless', 'score'], {
        ...executeConfig,
        parsers: {
            '3': (arg, innerArgs) => {
                if (innerArgs[2] === 'matches') {
                    return _variables_1.rangeParser(arg);
                }
                return arg;
            },
        },
    }),
    __metadata("design:type", Object)
], Execute.prototype, "unlessScore", void 0);
__decorate([
    decorators_1.command([], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "if_", void 0);
__decorate([
    decorators_1.command([], {
        isRoot: false, executable: true, hasSubcommands: false,
    }),
    __metadata("design:type", Object)
], Execute.prototype, "register", void 0);
exports.Execute = Execute;
class ExecuteWithRun extends Execute {
    /**
     * Runs one or multiple commands.
     *
     * When giving a callback, if it only creates one command, and this command is safe to be inlined,
     * it will be inlined to avoid a useless function call.
     *
     * @example
     * // Run multiple commands
     * execute.as(`@a`).run(() => {
     *    give(`@s`, 'minecraft:diamond', 1)
     *    kill(`@s`)
     * })
     *
     * // Run a single command
     * execute.as(`@s`).run.give(`@s`, 'minecraft:diamond', 1)
     */
    get run() {
        const runMultiple = ((nameOrCb, callbackOrUndefined) => {
            const datapack = this.commandsRoot.Datapack;
            const callback = (callbackOrUndefined !== null && callbackOrUndefined !== void 0 ? callbackOrUndefined : nameOrCb);
            const name = typeof nameOrCb === 'string' ? nameOrCb : undefined;
            const fallbackName = `execute_${this.commandsRoot.arguments[1]}`;
            if (utils_1.isAsyncFunction(callback)) {
                const realName = name !== null && name !== void 0 ? name : fallbackName;
                const mcFunction = datapack.createCallbackMCFunction(realName, callback, typeof name === 'undefined');
                mcFunction();
            }
            else {
                datapack.flow.flowStatement(callback, {
                    absoluteName: name,
                    callbackName: fallbackName,
                    initialCondition: false,
                    loopCondition: false,
                });
            }
        });
        // We need to add all CommandsRoot keys to this function.
        const keys = [
            ...Object.getOwnPropertyNames(this.commandsRoot),
            ...Object.getOwnPropertyNames(Object.getPrototypeOf(this.commandsRoot)),
        ];
        for (const key of keys) {
            /*
             * Filter away keys that are not commands. While that's not mandatory since TypeScript will not propose them with autocompletion,
             * it prevents overriding properties by mistake.
             *
             * However, it is MANDATORY to exclude "arguments" and "constructor", since those two properties exists on functions, and will cause a problem if kept.
             */
            if (['register', 'addAndRegister', 'arguments', 'inExecute', 'executable', 'Datapack', 'commandsRoot', 'constructor', 'reset'].includes(key)) {
                continue;
            }
            runMultiple[key] = (this.commandsRoot)[key];
        }
        this.commandsRoot.executeState = 'after';
        return runMultiple;
    }
}
exports.ExecuteWithRun = ExecuteWithRun;
