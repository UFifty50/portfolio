"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildProject = void 0;
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const util_1 = require("util");
const fs_extra_1 = __importDefault(require("fs-extra"));
const pretty_error_1 = __importDefault(require("pretty-error"));
const klaw_1 = __importDefault(require("klaw"));
const pe = new pretty_error_1.default();
// Return the hash of a string
function hash(stringToHash) {
    return crypto_1.default.createHash('md5').update(stringToHash).digest('hex');
}
// Recursively create a directory, without failing if it already exists
async function mkDir(dirPath) {
    try {
        await new Promise((resolve, reject) => {
            fs_extra_1.default.mkdir(dirPath, { recursive: true }, (err) => {
                if (err)
                    reject(err);
                resolve();
            });
        });
    }
    catch (error) {
        // Directory already exists
    }
}
/**
 * Recursively removes empty directories from the given directory.
 *
 * If the directory itself is empty, it is also removed.
 *
 * Code taken from: https://gist.github.com/jakub-g/5903dc7e4028133704a4
 *
 * @param {string} directory Path to the directory to clean up
 */
async function removeEmptyDirectories(directory) {
    // lstat does not follow symlinks (in contrast to stat)
    const fileStats = await fs_extra_1.default.lstat(directory);
    if (!fileStats.isDirectory()) {
        return;
    }
    let fileNames = await fs_extra_1.default.readdir(directory);
    if (fileNames.length > 0) {
        const recursiveRemovalPromises = fileNames.map((fileName) => removeEmptyDirectories(path_1.default.join(directory, fileName)));
        await Promise.all(recursiveRemovalPromises);
        // re-evaluate fileNames; after deleting subdirectory
        // we may have parent directory empty now
        fileNames = await fs_extra_1.default.readdir(directory);
    }
    if (fileNames.length === 0) {
        await fs_extra_1.default.rmdir(directory);
    }
}
const sandstoneMiscFolderName = '.sandstone';
const sandstoneCacheFileName = 'cache.json';
/**
 * Build the project, but might throw errors.
 *
 * @param options The options to build the project with.
 *
 * @param projectFolder The folder of the project. It needs a sandstone.config.ts, and it or one of its parent needs a package.json.
 */
async function _buildProject(options, { absProjectFolder, rootFolder, sandstoneConfigFolder }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const sandstoneLocation = path_1.default.join(rootFolder, 'node_modules/sandstone/');
    // First, read sandstone.config.ts to get all properties
    const sandstoneConfig = require(path_1.default.join(sandstoneConfigFolder, 'sandstone.config.ts')).default;
    const { saveOptions, scripts } = sandstoneConfig;
    /// OPTIONS ///
    // Check if the player overidded the save options
    const overrideSaveOptions = options.world || options.root || options.path;
    const world = overrideSaveOptions ? options.world : saveOptions.world;
    const root = overrideSaveOptions ? options.root : saveOptions.root;
    const customPath = overrideSaveOptions ? options.path : saveOptions.path;
    const minecraftPath = (_a = options.minecraftPath) !== null && _a !== void 0 ? _a : sandstoneConfig.minecraftPath;
    const dataPackName = (_b = options.name) !== null && _b !== void 0 ? _b : sandstoneConfig.name;
    if ([world, root, customPath].filter(x => x !== undefined).length > 1) {
        throw new Error(`Expected only 'world', 'root' or 'path'. Got at least two of them: world=${world}, root=${root}, path=${customPath}`);
    }
    // Important /!\: The below if statements, which set environment variables, must run before importing any Sandstone file.
    // Set the pack ID environment variable
    // Set production/development mode
    if (options.production) {
        process.env.SANDSTONE_ENV = 'production';
    }
    else {
        process.env.SANDSTONE_ENV = 'development';
    }
    if (sandstoneConfig.packUid) {
        process.env.PACK_UID = sandstoneConfig.packUid;
    }
    // Set the namespace
    const namespace = sandstoneConfig.namespace || options.namespace;
    if (namespace) {
        process.env.NAMESPACE = namespace;
    }
    // Set conflict strategies
    function setStrategy(strategyName, value) {
        if (value) {
            process.env[`${strategyName.toUpperCase()}_CONFLICT_STRATEGY`] = value;
        }
    }
    const { onConflict } = sandstoneConfig;
    setStrategy('general', onConflict === null || onConflict === void 0 ? void 0 : onConflict.default);
    setStrategy('advancement', onConflict === null || onConflict === void 0 ? void 0 : onConflict.advancement);
    setStrategy('loot_table', onConflict === null || onConflict === void 0 ? void 0 : onConflict.lootTable);
    setStrategy('mcfunction', onConflict === null || onConflict === void 0 ? void 0 : onConflict.mcFunction);
    setStrategy('predicate', onConflict === null || onConflict === void 0 ? void 0 : onConflict.predicate);
    setStrategy('recipe', onConflict === null || onConflict === void 0 ? void 0 : onConflict.recipe);
    setStrategy('tag', onConflict === null || onConflict === void 0 ? void 0 : onConflict.tag);
    // Configure error display
    if (!options.fullTrace) {
        pe.skipNodeFiles();
    }
    /// IMPORTING USER CODE ///
    // The configuration is ready.
    // Now, let's run the beforeAll script
    const { getDestinationPath } = require(path_1.default.join(sandstoneLocation, 'datapack', 'saveDatapack'));
    const destinationPath = getDestinationPath(dataPackName, { world, asRootDatapack: root, customPath, minecraftPath });
    await ((_c = scripts === null || scripts === void 0 ? void 0 : scripts.beforeAll) === null || _c === void 0 ? void 0 : _c.call(scripts, {
        dataPackName,
        destination: destinationPath,
    }));
    // Finally, let's import all .ts & .js files under ./src.
    let error = false;
    for await (const file of klaw_1.default(absProjectFolder)) {
        // Skip files not ending with .ts/.js
        if (!file.path.match(/\.(ts|js)$/)) {
            continue;
        }
        // We have a module, let's require it!
        try {
            require(path_1.default.resolve(file.path));
        }
        catch (e) {
            logError(e);
            error = true;
        }
    }
    if (error) {
        return;
    }
    /// SAVING RESULTS ///
    /* Let's load the previous cache */
    // Create .sandstone if it doesn't exists
    const sandstoneMiscFolder = path_1.default.join(rootFolder, sandstoneMiscFolderName);
    const sandstoneCacheFile = path_1.default.join(sandstoneMiscFolder, sandstoneCacheFileName);
    mkDir(sandstoneMiscFolder);
    // Try loading the cache
    let cache = {};
    const newCache = {
        files: {}
    };
    try {
        // Load the cache
        cache = JSON.parse((await fs_extra_1.default.readFile(sandstoneCacheFile)).toString());
    }
    catch (e) {
        // Either the file does not exists, or the cache isn't a proper JSON.
        // In that case, reset it.
        await fs_extra_1.default.writeFile(sandstoneCacheFile, JSON.stringify(cache));
    }
    if (cache[absProjectFolder] === undefined) {
        cache[absProjectFolder] = {
            files: {},
        };
    }
    // Save the pack
    const { savePack } = require(sandstoneLocation);
    // Run the beforeSave script
    await ((_d = scripts === null || scripts === void 0 ? void 0 : scripts.beforeSave) === null || _d === void 0 ? void 0 : _d.call(scripts, {
        dataPackName,
        destination: destinationPath,
    }));
    await savePack(dataPackName, {
        // Save location
        world: world,
        asRootDatapack: root,
        customPath: customPath,
        minecraftPath: minecraftPath,
        indentation: saveOptions.indentation,
        // Data pack mcmeta
        description: (_e = options.description) !== null && _e !== void 0 ? _e : sandstoneConfig.description,
        formatVersion: (_f = options.formatVersion) !== null && _f !== void 0 ? _f : saveOptions.formatVersion,
        // Additional parameters
        dryRun: options.dry,
        verbose: options.verbose,
        customFileHandler: (_g = saveOptions.customFileHandler) !== null && _g !== void 0 ? _g : (async ({ relativePath, content }) => {
            var _a;
            const realPath = path_1.default.join(destinationPath, relativePath);
            // We hash the real path alongside the content. 
            // Therefore, if the real path change (for example, the user changed the resulting directory), the file will be recreated.
            const hashValue = hash(content + realPath);
            // Add to new cache. We use the relative path as key to make the cache lighter.
            newCache.files[relativePath] = hashValue;
            newCache.resultFolder = destinationPath;
            if (((_a = cache[absProjectFolder].files) === null || _a === void 0 ? void 0 : _a[realPath]) === hashValue) {
                // Already in cache - skip
                return;
            }
            // Not in cache: write to disk
            await mkDir(path_1.default.dirname(realPath));
            return await fs_extra_1.default.writeFile(realPath, content);
        })
    });
    // Delete old files that aren't cached anymore
    const oldFilesNames = new Set(Object.keys(cache[absProjectFolder].files));
    Object.keys(newCache.files).forEach(name => oldFilesNames.delete(name));
    const previousResultFolder = (_h = cache === null || cache === void 0 ? void 0 : cache[absProjectFolder]) === null || _h === void 0 ? void 0 : _h.resultFolder;
    await Promise.allSettled([...oldFilesNames.values()].map(name => util_1.promisify(fs_extra_1.default.rm)(path_1.default.join(previousResultFolder !== null && previousResultFolder !== void 0 ? previousResultFolder : '', name))));
    // Delete all empty folders of previous directory
    if (previousResultFolder !== undefined) {
        try {
            await removeEmptyDirectories(previousResultFolder);
        }
        catch (e) {
            // Previous directory was deleted by the user himself
        }
    }
    // Override old cache
    cache[absProjectFolder] = newCache;
    await fs_extra_1.default.writeFile(sandstoneCacheFile, JSON.stringify(cache, null, 2));
    // Run the afterAll script
    await ((_j = scripts === null || scripts === void 0 ? void 0 : scripts.afterAll) === null || _j === void 0 ? void 0 : _j.call(scripts, {
        dataPackName,
        destination: destinationPath,
    }));
}
/**
 * Build the project. Will log errors and never throw any.
 *
 * @param options The options to build the project with.
 *
 * @param projectFolder The folder of the project. It needs a sandstone.config.ts, and it or one of its parent needs a package.json.
 */
async function buildProject(options, folders) {
    try {
        await _buildProject(options, folders);
    }
    catch (err) {
        logError(err);
    }
}
exports.buildProject = buildProject;
function logError(err) {
    if (err) {
        console.error(pe.render(err));
    }
}
process.on('unhandledRejection', logError);
process.on('uncaughtException', logError);
