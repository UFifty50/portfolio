"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectFolders = exports.getFileFolder = exports.getWorldPath = exports.getWorldsList = exports.getMinecraftPath = exports.hasYarn = exports.getFlagOrPrompt = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const chalk_1 = __importDefault(require("chalk"));
async function getFlagOrPrompt(flags, name, inquirerProps) {
    const flagValue = flags[name];
    if (typeof flagValue === 'string') {
        return flagValue;
    }
    return (await inquirer_1.default.prompt({ name, ...inquirerProps }))[name];
}
exports.getFlagOrPrompt = getFlagOrPrompt;
function hasYarn() {
    try {
        child_process_1.execSync('yarn --version');
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.hasYarn = hasYarn;
/**
 * Get the .minecraft path
 */
function getMinecraftPath() {
    function getMCPath() {
        switch (os_1.default.platform()) {
            case 'win32':
                return path_1.default.join(os_1.default.homedir(), 'AppData/Roaming/.minecraft');
            case 'darwin':
                return path_1.default.join(os_1.default.homedir(), 'Library/Application Support/minecraft');
            case 'linux':
            default:
                return path_1.default.join(os_1.default.homedir(), '.minecraft');
        }
    }
    const mcPath = getMCPath();
    if (!fs_1.default.existsSync(mcPath)) {
        throw new Error('Unable to locate the .minecraft folder. Please specify it manually.');
    }
    return mcPath;
}
exports.getMinecraftPath = getMinecraftPath;
function getWorldsList() {
    const mcPath = getMinecraftPath();
    const savesPath = path_1.default.join(mcPath, 'saves');
    return fs_1.default.readdirSync(savesPath, { withFileTypes: true }).filter((f) => f.isDirectory).map((f) => f.name);
}
exports.getWorldsList = getWorldsList;
/**
 * @param worldName The name of the world
 * @param minecraftPath The optional location of the .minecraft folder.
 * If left unspecified, the .minecraft will be found automatically.
 */
function getWorldPath(worldName, minecraftPath = undefined) {
    let mcPath;
    if (minecraftPath) {
        mcPath = minecraftPath;
    }
    else {
        mcPath = getMinecraftPath();
    }
    const savesPath = path_1.default.join(mcPath, 'saves');
    const worldPath = path_1.default.join(savesPath, worldName);
    if (!fs_1.default.existsSync(worldPath)) {
        const existingWorlds = fs_1.default.readdirSync(savesPath, { withFileTypes: true }).filter((f) => f.isDirectory).map((f) => f.name);
        throw new Error(`Unable to locate the "${worldPath}" folder. Word ${worldName} does not exists. List of existing worlds: ${JSON.stringify(existingWorlds, null, 2)}`);
    }
    return worldPath;
}
exports.getWorldPath = getWorldPath;
/**
 * Recursively search for a file.
 * Starts in the current folder, and go to the parent, recursively.
 *
 * @param filename the name of the file to resolve
 * @param from the path to start at
 *
 * @return The path on success, `null` if no the file is found in any parent.
 */
function getFileFolder(filename, from = '.') {
    let fileFolder = path_1.default.resolve(from);
    while (!fs_1.default.existsSync(path_1.default.join(fileFolder, filename))) {
        // Go up 1 folder
        const newFileFolder = path_1.default.dirname(fileFolder);
        if (newFileFolder == fileFolder) {
            // If we arrived to the root folder, give up.
            return null;
        }
        fileFolder = newFileFolder;
    }
    return fileFolder;
}
exports.getFileFolder = getFileFolder;
function getProjectFolders(projectFolder) {
    const absProjectFolder = path_1.default.resolve(projectFolder);
    /// GETTING ALL MANDATORY FILES ///
    // Resolve the location of package.json, in order to get the node_modules folder.
    const rootFolder = getFileFolder('package.json', projectFolder);
    if (!rootFolder) {
        throw new Error(chalk_1.default `{red Failed to find {bold package.json} in the "${absProjectFolder}" folder, or in any parent folder.}`);
    }
    // Resolve the location of sandstone.config.ts
    const sandstoneConfigFolder = getFileFolder('sandstone.config.ts', projectFolder);
    if (!sandstoneConfigFolder) {
        throw new Error(chalk_1.default `{red Failed to find {bold sandstone.config.ts} in the "${absProjectFolder}" folder, or in any parent folder.}`);
    }
    return {
        absProjectFolder, rootFolder, sandstoneConfigFolder
    };
}
exports.getProjectFolders = getProjectFolders;
